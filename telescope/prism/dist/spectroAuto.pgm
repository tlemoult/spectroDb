# 1 "<stdin>"
# 1 "<interne>"
# 1 "<command-line>"
# 1 "<stdin>"

	raisonEchec$=""
	GOSUB generalSettings:
	GOSUB checkDstDirOk:
	GOSUB Dialog_param_et_Charge_LST_et_defini_cible:
	GOSUB LampCalibOff:

	Print "Boucle seance lancee."
	if (ActiveLancementImmediat=1) THEN
		Print "On observe sans attendre la meteo"
		CompteurBeauTemp=ValMinBelleMeteo+1
		GOTO entreSeanceImmediat:
	ENDIF
	
boucleSeance:
	Print "attente d un ciel noir"
	// gosub set_cooling_camera_off:
	GOSUB BoucleAttendBeauTemp:
entreSeanceImmediat:
	GOSUB seance-observation:
	goto boucleSeance:
exit

seance-observation:
	print "on commence a observer"
	GOSUB ConfigCamera:
	GOSUB set_cooling_camera_on:
	
	gosub init_dome_telescope:
	gosub Oriente_Camera:
	
	GOSUB setWorkDirGeneral:
	GOSUB OuvreFichierLog:

	GOSUB wait_cooling_camera_ready:

RebouclageGeneral:

	FlagPremierObjet=1
	// compteur Sucess de la boucle
	nbSucess=0
	// compteur Sucess total, cette boucle et les precedantes.
	nbTRUE=0

For iobj=1 nbCibles
	Print "------------------------------------------------------------"
	/////////////// test meteo , s il faut mauvais on arrete les observations
	GOSUB ReadMeteo:
	if (BeauTemp=0)
		now date
		DATETOSTR  Date  Date$
		log$=Date$+": Il ne fait pas beau, on arrete les observations."
		WriteFileTxt fileLog log$
		Print log$
		goto MinaLoopGeneralSoleilLevÃ©:
	endif

	/////////////////// test du leve du soleil
	gosub test_levee_soleil:
	if (soleil_levee=1)
		goto MinaLoopGeneralSoleilLevÃ©:
	endif
	
	//// recupere les donnÃ©es de l'objet courant
	ProjectObject$=ProjectObject[iobj]$
	IsRef$=IsRef[iobj]$
	
	AlphaObjet$=Alpha[iobj]$
	RA_TO_RAD AlphaObjet$ AlphaObjet
	DeltaObjet$=Delta[iobj]$
	DEC_TO_RAD DeltaObjet$ DeltaObjet
	nbExposureObjet=nbExposureObjet[iobj]
	exposureTimeObjet=exposureTimeObjet[iobj]
	NomObjet$=NomObjet[iobj]$
	AltName$=AltName[iobj]$
	Comment$=Comment[iobj]$
	MagnitudeObjet=Magnitude[iobj]
	STR MagnitudeObjet MagnitudeObjet$
	
	GuideMode$=GuideMode[iobj]$
	RAGuide$=GuideRA[iobj]$
	DECGuide$=GuideDEC[iobj]$
	ExposureMode$=ExposureMode[iobj]$
	exposureTimeObjet=ExposureUnit[iobj]
    nbExposureObjet=Nbexposure[iobj]
    TotExposure=TotExposure[iobj]
	
	// objet deja observÃ©
	if (Observe[iobj]$="TRUE") then
		nbTRUE=nbTRUE+1
		goto MaincibleSuivante:
	ENDIF
	
	// test visibilitÃ©e =  mini<hauteur<max 
	now date
	gosub test_visibilitee:
	if OK_visible=0 THEN
		goto MaincibleSuivante:
	ENDIF
	
	// affine la position de la fente en l eclairant 
	if activeAffinePositionFenteAuto=1 then
		GOSUB affine_position_fente:
	endif
	
	GOSUB setWorkDir:
	currentStatusObs$="started"
	GOSUB write_JSON_Observation:
	//////////////// Pointage initial et test du meridien
	Print "Cible suivante" NomObjet$ "  " AltName$ " " Comment$ "  Mag=" MagnitudeObjet$
	Print "Project=" ProjectObject$

	// on interdit le changement de meridien, sauf au premier pointage evideament..
	// la premiere cible determine donc le cotÃ© du mÃ©ridien pour la suite
	GOSUB test_retournement_necessaire:	
	if (FlagPremierObjet=0) then
		if (RetournementNecessaire+bloqueChangementCoteMeridien=2) then
			Print "Cible " NomObjet$ " ignore car du mauvais cote du meridien"
			raisonEchec$="Pas du bon cote du meridien"
			GOSUB LogObservationEchec:
			goto MaincibleSuivante:
		endif
	endif

	
	GOSUB Pointe_et_gere_retournement:
	GOSUB attente_dome:

	GOSUB LampCalibOff:
	// si double calibration demande
	IF  CalibrationAsk[iobj]=2 THEN
		// on ajoute un prefixe au nomb de l objet pour eviter d ecraser cette calib
		// lors de la calib apres acquisition
		NomObjet$=NomObjet[iobj]$+"-a"
		GOSUB Calibration:
	ENDIF

	// affine le pointage
	GOSUB High_level_Centrage:
	if (ResultatHighLevelCentrage=0) then
		Print "Cible suivante"
		raisonEchec$="Pb de pointage, astrometrie"
		GOSUB LogObservationEchec:
		currentStatusObs$="failed"
		GOSUB write_JSON_Observation:
		goto MaincibleSuivante:
	ENDIF
	
	// parametrage du guidage //
	Gosub determine_etoile_guide:

	// observation
	GOSUB lance_guidage:
	if valid<>0 then
		// autoguidage a echoue
		raisonEchec$="Pb de guidage"
		GOSUB LogObservationEchec:
		goto MaincibleSuivante:
	endif
	GOSUB auto_exposure:
	//GOSUB PosePhotometrieChercheur:
	GOSUB Acquisition:
	GOSUB arret_guidage:
	
	// calibration a la fin de l acqusition
	IF  CalibrationAsk[iobj]<>0 THEN
		STOPTELESCOPE
		GOSUB Calibration:
	ENDIF
	
	// tout c est bien passÃ©
	GOSUB LogObservationSuccess:
	Observe[iobj]$="TRUE"
	nbTRUE=nbTRUE+1
	nbSucess=nbSucess+1
	// On prepare le fichier JSON pour le pipeline de traitement des donnÃ©es
	currentStatusObs$="finished"
	GOSUB write_JSON_Observation:

	// integration a la base de donne
	// Remplace par signals...   //EXECEXTERNAL   PathBatBaseIn$ PathBatBaseInArgs$
	
MaincibleSuivante:
	Print "passe a la cible suivante"
NEXT iobj

	//  si on a fini, on sort de la boucle... 
	if (nbTRUE=nbCibles) then
		msg$="Tous les objets de la liste ont ete observe avec succes."
		Print msg$
		WriteFileTxt fileLog msg$
		GOSUB finseance:
		END
		
	ENDIF
	
	// Il reste des objet a observer, on va reboucler..
	if (nbSucess=0) then
		GOSUB attente_sans_succes:
	endif

	now date
	STR nbSucess nbSucess$
	DATETOSTR  Date  Date$
	WriteFileTxt fileLog Date$+": Rebouclage sur les cibles, apres "+nbSucess$+" sucess" 
	WriteFileTxt fileLog Date$+"-----------------------------------------------------------"

	Print "rebouclage"
	goto RebouclageGeneral:
	
MinaLoopGeneralSoleilLevÃ©:
	GOSUB finseance:

	return

attente_sans_succes:
		// aucun success...  on attend un peu que ca passe...
		Print "Aucun success dans la boucle precedante, attente que ca passe"
		print "stop entrainment horaire"
		STOPTELESCOPE
		now date
		DATETOSTR  Date  Date$
		WriteFileTxt fileLog Date$+": Aucun success dans la boucle precedante, attente que ca passe, arret entrainement horaire"
		for irty=1 DureeAttenteSiAucunSucces
// Ajout ici..
			GOSUB ReadMeteo:
			if (BeauTemp=0) THEN
				print "Mauvais temps pendant l attente"
				now date
				DATETOSTR  Date  Date$
				WriteFileTxt fileLog Date$+": Mauvais temps detectee pendant l attente"
				return
			ENDIF		

			print "    " irty "/" DureeAttenteSiAucunSucces
			delay 60000
			waitForendDelay
		next irty
		now date
		DATETOSTR  Date  Date$
		WriteFileTxt fileLog Date$+"Rebouclage----------------------------------------------------------"		
		return
				
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////
High_level_Centrage:
	if (FlagPremierObjet+RetournementNecessaire<>0) then
	    print "c est le premier pointage ou on vient de se retourner"
		FlagPremierObjet=0
		GOTO AstroPasseParLeChercheur:
	endif
	
	GOSUB RecaleAllSkyAstrometrieChamp:
	if (resultat_astrometrie_absolue=1) then
		// on est bon
		ResultatHighLevelCentrage=1
		return
	endif
	
AstroPasseParLeChercheur:
	Print "tentative au chercheur"
	now date
	STR nbSucess nbSucess$
	DATETOSTR  Date  Date$
	WriteFileTxt fileLog Date$+": passage par le recentrage au chercheur.." 
	GOSUB RecaleAllSkyAstrometrieChercheur:
	if (resultat_astrometrie_absolue=0) then
		DATETOSTR  Date  Date$
		WriteFileTxt fileLog Date$+": Echec recentrage au chercheur.."
		ResultatHighLevelCentrage=0
		return
	ENDIF

	GOSUB RecaleAllSkyAstrometrieChamp:
	if (resultat_astrometrie_absolue=1) then
		DATETOSTR  Date  Date$
		WriteFileTxt fileLog Date$+": reussite astrometrie sur le champ apres recentrage au chercheur.." 
		ResultatHighLevelCentrage=1
		return
	ELSE
		DATETOSTR  Date  Date$
		WriteFileTxt fileLog Date$+": Echec astrometrie sur le champ apres recentrage au chercheur.." 
		Print "Echec de la fonction de centrage...."
		ResultatHighLevelCentrage=0
		return
	ENDIF

return

// on place toutes les procedures a la fin, sinon elle sont executee sans meme un appel...

# 1 "./setting/generalSettings.pgm" 1



generalSettings:

// parametre d'exposition automatique sur le spectre  (auto_exposure.pgm)
DefaultTotalExposure=3600
NbPoseMax=29
NbPoseMin=3
maxDyn=25000
TargetFlux=300000

DirCible$="C:\Users\DELL\Dropbox\astro\cibles\journalier\"

REM chemin de sauvegarde des acquistions
Directory$="X:\astro\base\in"
DirectorySignals$="X:\astro\base\signals\fromPRISM"
REM Chemin racines des catalogues pour l astrometrie
sDirCatalogue$="C:\catalogues\"

REM Chemin des scripts python qui declenchent les lampes de calibration via le port serie
pathPythonInterpreter$="C:\Python27\python.exe"
pathPythonScript$="C:\Users\thierry\Dropbox\python\powercontrol\"
PythonScriptNeonLISALHIRESOn$=pathPythonScript$+"neon-on.py"
PythonScriptNeonLISALHIRESOff$=pathPythonScript$+"neon-off.py"
PythonScriptFinDeSeance$=pathPythonScript$+"alim-off-fin-seance.py"
PythonScriptFLATLISALHIRESOff$=pathPythonScript$+"FLAT-off.py"
PythonScriptFLATLISALHIRESOn$=pathPythonScript$+"FLAT-on.py"

PythonScriptControlIPX800$="C:\Users\DELL\Dropbox\python\powercontrol\IPX800set.py"
PythonScriptControlBox$="C:\Users\DELL\Dropbox\python\powercontrol\PowerBoxSet.py"

PathBatBaseIn$="C:\Program Files\putty\plink.exe"
PathBatBaseInArgs$="-load Linux-bureau -l tlemoult /home/tlemoult/Dropbox/python/spectroAutoPubli/robot-1-in-db/run.sh"
		
// type de spectrographe valeur possible:  "ESHEL"  "LISA"  "LHIRES"
SPECTROGRAPHE$="ESHEL"

// lampe de calibration commande par ordinateur (1) ou manuel (0)
LampeCalibAuto=1

// logique de recalage
ask_astrometrie_champ_absolue=1
ask_astrometrie_champ=0
ask_astrometrie_chercheur=0
ask_approche_plusbrillante_champ=0

// taille fenetre recherche etoile de guidage
WindowAllFrame=50
// taille fenetre evaluation flux etoile guide
WindowEvalGuideStar=20

// dit que les cameras ne sont pas initialise
configCameraDone=0
//parametres des cameras
CameraChamp=1
binCameraChamp=2
MiroirXCameraChamp=0
MiroirYCameraChamp=0
TempCameraChamp=0
DirRepChamp=0
AngleCCDChampWEST=174
FocaleCameraChamp=2111

CameraSpectre=2
binCameraSpectre=2
MiroirXCameraSpectre=0
MiroirYCameraSpectre=0
TempCameraSpectre=0

// 1-> camera presente  0->1
CameraChercheurPresente=1
CameraChercheurName$="ZWO"
CameraChercheur=3

if CameraChercheurName$="ZWO" then
	DirRepChercheur=0
	MiroirXCameraChercheur=0
	MiroirYCameraChercheur=0
	FocaleCameraChercheur=133.5
	binCameraChercheur=2
	AngleCCDChercheurWEST=179
	ChercheurPosXBin=344.8
	ChercheurPosYBin=256.7
else
    // Lodestar (config de backup)
	DirRepChercheur=0
	MiroirXCameraChercheur=0
	MiroirYCameraChercheur=0
	FocaleCameraChercheur=133.5
	AngleCCDChercheurWEST=179
	binCameraChercheur=1
	ChercheurPosXBin=150	
	ChercheurPosYBin=496
endif

exposurephotometriechercheur=3

/////////////////////Limite liee au pointage ////////////////////
// securitee hauteur pointage     1->actif  0->inactif
testHauteurTelescope=1
HautDegMiniTelescope=20
HautDegMaxTelecope=80
// gestion du passage du meridien  pendant les poses(monture allemande)
testColisionMeridien=1
// blocage du passage du meridien,  On n'observe pas les cibles qui demandent un changement coté de méridien.
// 1->Bloque    0-> authorisé
bloqueChangementCoteMeridien=0
//hauteur limite du soleil sous l'horizon en degré
ElevationMaxSun=-8
// attente en minute avant un rebouclage si tout a echoue.. 
DureeAttenteSiAucunSucces=30
// Flag pour declencher le parking a la fin du script, sinon l entrainment horaire s'arrete simplement.
ActiveParkingTelescope=1
// Position pour le parking en radian
// HA=Hangle horaire   De=Declinaison
ParkHa=0.0174
ParkDe=-0.677330

// delas en ms apres un pointage pour reprise de l'entrainement horaire
DelayRepriseRA=10000

// Flag pour couper l alimentation des cameras en fin de session.
ActiveCoupureCameraFinSession=1
DurationAttenteAvantCoupeCameraMillis=60000


// presence d'une coupole  1=> Oui   0=>non
coupole=1

// parametrage liee a la fente / trou de guidage
// affine position de la fente au cours du temps
//  0-> non actif   1->actif
activeAffinePositionFenteAuto=0

// orientation de la fente
OriFenteHorizon=1
OriFentevertical=2
OrientationFente=OriFentevertical

// Position cible du guidage
// attention au binning !,  si l'on change le bin  les coordonnes ici doivent changer.
// refocus...
// 17-02-2016: en bin1:  X=686, Y=548,  en bin 2: 343, 275
// 12-03-2016. 347, 275
// 13-03-2016  avant meridien: 343, 274
//         apres meridien:  344, 275  344, 275
// 14-03-2016   343, 275
// 05-07-2016   344, 274
// jusqu'au 18/01/2017   X=342 Y=274

fentePosX=341
fentePosY=274


// FLAT LISA LHIRES
ActiveFlatLISALHIRESFinSession=0
NbFlatLISALHIRES=31
exposureTimeFLATLISA=5

// temps de pose des calibrations
// LISA  => deux poses de calibration
exposureTimeNeonLISA1=5
exposureTimeNeonLISA2=10

// LHIRES => deux poses de calibration
exposureTimeNeonLHIRES1=2
exposureTimeNeonLHIRES2=10

// eShel temps et quantitee poses de calibration 
nbExposureTungsten=8
exposureTimeTungsten=10
nbExposureLED=3
exposureTimeLED=10
nbExposureThar=3
exposureTimeThar=3

// Etoile de dégagement si échec reconnaissance du ciel :
Radius=9
MagMin=3
MagMax=7



// heure de debut de la seance d observation
AA_Start=2014
Mo_Start=07
JJ_Start=05
HH_Start=22
MM_Start=28
ENCODEDATETIME  AA_Start  Mo_Start  JJ_Start  HH_Start  MM_Start  0  0  Date_Start
DATETOSTR  Date_Start Date_Start$

// temperature du ciel pour considerer qu il fait beau..
LimitTempCiel=10
// magnitude limite pour considere que le ciel est bien noir..  16.6
LimitMagnitudeCiel=16.8
// après cette valeur de compteur, on lance les observations, une unitee = 1 minute d attente
ValMinBelleMeteo=6
CompteurBeauTemp=0
// valeur par defaut, activation observation immediate au lance du script sans verif meteo
ActiveLancementImmediat=1



// definition interrupteurs commande module calibraion via la carte Vellmann eShell
ON=1
OFF=0
switchmirroir=1
switchled=2
switchthar=3
switchtungsten=4
delayswitch=180
pauseAfterLightOn=5

// RESSOURCESTRING :
STR_01$="Télescope côté "
STR_02$="Objet pointé vers "
STR_03$="Pas de retournement de monture nécessaire"
STR_04$="Retournement de monture nécessaire"
STR_05$="Pointe vers "
STR_06$="Pose de reconnaissance de champ sur caméra n°"
STR_07$="ECHEC - find all sky telescope - sur Camera n°"
STR_08$="REUSSITE - find all sky telescope - sur Camera n°"
STR_09$="Reconnaissance de champ au niveau de l'objet :"
STR_10$="Comparaison lancée ..."
STR_11$="Astrométrie sur le champ"
STR_12$="Reconnaissance astrométrique lancée ..."
STR_13$="Détermination de la position de l'objet sur l'image reconnue astrométriquement"
STR_14$="Position de l'objet sur l'image étalonnée astrométriquement : X = "
STR_15$="Déplacement vers : X = "
STR_16$="Echec de détermination de X_objet et de Y_objet"
STR_17$="Début de l'autoguidage sur Consigne"
STR_18$="Status de guidage : Guidage en cours, Dernier Message=["
STR_19$="Status de guidage : Guidage INACTIF, Dernier Message=["
STR_20$="L'étalonnage de l'image est OK"
STR_21$="Echec de l'étalonnage astrométrique !"
STR_22$="On ne peut plus rien pour vous !"
STR_23$="Pas d'étoile de dégagement. Elargir le champ de recherche !"

GetStdrLongitude Longitude

return
# 292 "<stdin>" 2

# 1 "./lib/generalSubroutine.pgm" 1




//############################
//# Pointage    au coord    AlphaDest et  DeltaDest
//############################
Pointage:
  allowmovedome=1
  MoveTelescope AlphaDest DeltaDest allowmovedome
  RAD_TO_RA AlphaDest AlphaDest$
  RAD_TO_DEC DeltaDest DeltaDest$
  Chaine$="pointe le telescope sur "+AlphaDest$+"  "+DeltaDest$
  PRINT Chaine$
  WaitForEndMoveTelescope
  PRINT "   Pointage termine"
RETURN


CalcPierSide:
// De quel côté est le télescope ?
PIERSIDE_TEL ActualSide$
Chaine$=STR_01$+ActualSide$
PRINT Chaine$
return

setWorkDirGeneral:
	NOW Cyear Cmonth Cday Chour CMinute CSecond CMillisec
	STR Cyear Cyear$
	STR Cmonth Cmonth$
	STR Cday Cday$
	STR Chour Chour$
	STR CMinute CMinute$
	STR CSecond CSecond$
	DateSession$=Cyear$+"-"+Cmonth$+"-"+Cday$+"_"+Chour$+"h"+CMinute$+"m"+CSecond$
	GeneralWorkDir$=Directory$+"\"+DateSession$+"_"+SPECTROGRAPHE$+"_RACINE\"
	Print "Repertoire de travail general: "+GeneralWorkDir$
	CreateDir GeneralWorkDir$
RETURN

checkDstDirOk:
	print "checkDstDir " Directory$
	testfilename$=Directory$+"\"+"testFilePRISM"
	Open_FileTxt_For_Rewrite fileTest testfilename$
	CloseFileTxt fileTest
	return

OuvreFichierLog:
	Open_FileTxt_For_Rewrite fileLog GeneralWorkDir$+"logAutoObservation-"+DateSession$+".txt"
	Open_FileTxt_For_Rewrite fileRealise GeneralWorkDir$+"realise-"+DateSession$+".LST"
	
	WriteFileTxt fileLog "Fichier general de log"
	WriteFileTxt fileLog "----------------------"
	RETURN

FermeFichierLog:
	CloseFileTxt fileLog
	RETURN

LogObservationSuccess:
	now date
	DATETOSTR  Date  Date$
	STR nbExposureObjet nbExposureObjet$
	STR exposureTimeObjet exposureTimeObjet$
	STR hauteur hauteur$
	LogMessage$=Date$+": reussite "+NomObjet$+" "+AltName$+" "+Comment$+" Mag="+MagnitudeObjet$+"  Exposition="+nbExposureObjet$+"x"+exposureTimeObjet$+"sec  Hauteur="+hauteur$+" deg Ha="+Ha$
	writeFileTxt fileLog LogMessage$
	Ligne$=LigneLST[iobj]$
	WriteFileTxt fileRealise Ligne$
	Return

LogObservationEchec:
	now date
	DATETOSTR  Date  Date$
	STR hauteur hauteur$
	LogMessage$=Date$+": Echec "+raisonEchec$+NomObjet$+" "+AltName$+" "+Comment$+" Mag="+MagnitudeObjet$+" Hauteur="+hauteur$+" deg  Ha="+Ha$
	writeFileTxt fileLog LogMessage$
	Return

GeneNextLSTTarget:
	print "prepare les listes au format LST du reste a faire., et realise."
	Open_FileTxt_For_Rewrite fileReste GeneralWorkDir$+"resteAfaire-"+DateSession$+".LST"

	success=0
	For iobj=1 nbCibles
		if (Observe[iobj]$="FALSE") then
			Ligne$=LigneLST[iobj]$
			WriteFileTxt fileReste Ligne$
		ELSE
			success=success+1
		endif
	next iobj
	Print "Total des succes " success " sur un total de " nbCibles
	CloseFileTxt fileReste
	CloseFileTxt fileRealise
	return
	


# 293 "<stdin>" 2

# 1 "./lib/init_dome_telescope.pgm" 1


init_dome_telescope:
	Print "----------------------------------------------------------------"
	Print "Initialisation dome et telescope"
	if coupole=1 THEN
		// dome asservit sur suivit et pointage
		DOME_SET_CONTROL 1 1

		GET_DOME_POS  Azimuth  Status Statusb
		IF Statusb=3
			print "Le dome est fermé, donc on l'ouvre"
			OPEN_DOME
		ELSE
			print "dome deja ouvert"
		ENDIF
	endif
		
return
# 294 "<stdin>" 2

# 1 "./lib/init_camera.pgm" 1

ConfigCamera:

	if configCameraDone=1 THEN
		print "cameras deja configure, on passe a la suite"
		return
	endif

	CLEARIMGWINDOWS
	durationOffsetInit=10
    //////////  Champ	  ///////////
	Print "Initialise camera Champ"	
	print "   Mise sous tension"
	parm$=PythonScriptControlBox$+" 1=1"
	EXECEXTERNAL   pathPythonInterpreter$ parm$
	delay 5000
	WAITFORENDDELAY
	
	print "   Connexion"
	INIT_CCD_CAMERA_EX CameraChamp Valid Cause$
	if Valid<>2 THEN
		print "erreur" Cause$
	endif

	print "   Configuration"
	SETBINNINGX_EX CameraChamp binCameraChamp
	SETBINNINGY_EX CameraChamp binCameraChamp
	SetWindowFullFrame_EX CameraChamp
	SetFlagShutter_EX CameraChamp 0
	
	StartExposure_EX CameraChamp durationOffsetInit
	WaitForEndExposure_EX CameraChamp
	GetLastImageExposure_EX CameraChamp img2
	GETBACKGROUND  img2  OffsetValueCameraChamp  Sigma
	Print "   Offset Camera Champ " OffsetValueCameraChamp " ADU"
	GetSizePixX img2 TaillePixXCameraChamp
	GetSizePixY img2 TaillePixYCameraChamp
	GetFocus img2 FocaleCameraChamp
	WIDTH img2 WidthImgCameraChamp
	HEIGHT Img2 HeightImgCameraChamp
	Close Img2
	CLEARIMGWINDOWS
	
	if AngleCCDChampWEST<180 then
		AngleCCDChampEAST=AngleCCDChampWEST+180
	else
		AngleCCDChampEAST=AngleCCDChampWEST-180
	EndIf


	//////  Spectro ///////////
	Print "Initialize Camera Spectro"
	print "   Mise sous tension"
	parm$=PythonScriptControlIPX800$+"  5=1"
	EXECEXTERNAL   pathPythonInterpreter$ parm$
	delay 5000
	WAITFORENDDELAY
	
	print "   Connexion"
	INIT_CCD_CAMERA_EX CameraSpectre Valid Cause$
	if Valid<>2 THEN
		print "erreur" Cause$
	endif

	print "   Configuration"	
	SETBINNINGX_EX CameraSpectre binCameraSpectre
	SETBINNINGY_EX CameraSpectre binCameraSpectre
	SetMirror_EX CameraSpectre MiroirXCameraSpectre MiroirYCameraSpectre
	SetWindowFullFrame_EX CameraSpectre
	SetFlagShutter_EX CameraSpectre 0
	
	StartExposure_EX CameraSpectre durationOffsetInit
	WaitForEndExposure_EX CameraSpectre
	GetLastImageExposure_EX CameraSpectre img3
	GETBACKGROUND  Img3  OffsetValueCameraSpectre  Sigma
	Print "   Offset Camera Spectre " OffsetValueCameraSpectre " ADU"
	Close img3
	CLEARIMGWINDOWS

	
    ////// Chercheur   ////////////
	if CameraChercheurPresente=1 then
		Print "Initialise camera Chercheur"
		//print "   Connexion"

		// commente car fonction buggue pour le chercheur (cam 3)  fonctionne bien pour les deux premiere cameras
		//INIT_CCD_CAMERA_EX CameraChercheur Valid Cause$
		//if Valid<>2 THEN
		//	print "erreur" Cause$
		//endif

		print "   Configuration"		
		SETBINNINGX_EX CameraChercheur binCameraChercheur
		SETBINNINGY_EX CameraChercheur binCameraChercheur
		SetWindowFullFrame_EX CameraChercheur
		SetFlagShutter_EX CameraChercheur 0
		StartExposure_EX CameraChercheur  durationOffsetInit
		WaitForEndExposure_EX CameraChercheur
		GetLastImageExposure_EX CameraChercheur img1
		GetSizePixX img1 TaillePixXCameraChercheur
		GetSizePixY img1 TaillePixYCameraChercheur
		GetFocus img1 FocaleCameraChercheur
		WIDTH img1 WidthImgCameraChercheur
		HEIGHT Img1 HeightImgCameraChercheur
		Close Img1
		CLEARIMGWINDOWS
		
		if AngleCCDChercheurWEST<180 then
			AngleCCDChercheurEAST=AngleCCDChercheurWEST+180
		else
			AngleCCDChercheurEAST=AngleCCDChercheurWEST-180
		EndIf

	endif

	
return


set_cooling_camera_on:
	print "Mise en route des refroidissements de camera"
	SETCCDTEMPERATURE_EX CameraChamp  1 TempCameraChamp
	SETCCDTEMPERATURE_EX CameraSpectre  1 TempCameraSpectre
	return

wait_cooling_camera_ready:
	print "On attend que la temperature de consigne soit atteinte"
	
boucle_cooling_ready:
	iboucleCollingReady=1
	// recupere la temperature du capteur
	GETCCDTEMPERATURE_Ex CameraSpectre 1 ActualTempSpectre
	difTemp=ActualTempSpectre-TempCameraSpectre
	abs difTemp difTemp
	if difTemp>3.0 then
		print "    Consigne temp=" TempCameraSpectre " actualTemp=" ActualTempSpectre " delta=" difTemp
		delay 10000
		WAITFORENDDELAY
		iboucleCollingReady=iboucleCollingReady+1
		if iboucleCollingReady<>30 Then
			goto boucle_cooling_ready:
		endif
		print "Mise en temperature trop longue, on abandonne"
		return
		
	endif
	print "Temperature de consigne atteinte"
	
return

set_cooling_camera_off:
	print "Arret du refroidissement des cameras"
	TempCameraHot=45
	SETCCDTEMPERATURE_EX CameraChamp  1 TempCameraHot
	SETCCDTEMPERATURE_EX CameraSpectre  1 TempCameraHot
return

//#########################
//#  Orientation Camera   #
//#########################
Oriente_Camera:
	Print "Orientation des cameras suivant position du telescope"
	GOSUB CalcPierSide:

	SetMirror_EX CameraChamp MiroirXCameraChamp MiroirYCameraChamp
	SetCCDRepDirCamHeader CameraChamp DirRepChamp

	SetMirror_EX CameraChamp MiroirXCameraChercheur MiroirYCameraChercheur
	SetCCDRepDirCamHeader CameraChercheur DirRepChercheur
	
	if ActualSide$="WEST" then
		SetCCDOriCamHeader CameraChercheur  AngleCCDChercheurWEST
		SetCCDOriCamHeader CameraChamp  AngleCCDChampWEST
	else
		SetCCDOriCamHeader CameraChercheur  AngleCCDChercheurEAST
		SetCCDOriCamHeader CameraChamp  AngleCCDChampEAST
	EndIf

return




# 295 "<stdin>" 2

# 1 "./lib/approcheEtoileBrillante.pgm" 1
approcheEtoileChamp:
	name$="Champ"
	camera=CameraChamp
	exposure=3
	PSFMin=1.5
	DemiLargeur=15
	SeuilDetection=500
	Xpos=fentePosX
	Ypos=fentePosY
	GOSUB approcheetoile:
	
return

approcheEtoileChercheur:
	name$="Chercheur"
	camera=CameraChercheur
	exposure=3
	PSFMin=1.5
	DemiLargeur=15
	SeuilDetection=500
	Xpos=ChercheurPosXBin
	Ypos=ChercheurPosYBin
	GOSUB approcheetoile:

return

approcheetoile:
	GOSUB Oriente_Camera:
	print Name$ ": approche etoile "
	//#je recupere les coor ou je veux aller !
	GET_TELESCOPE_POSITION CIBLEAD2000 CIBLEDEC2000 Haut Azi AHor

	print "   lancement d une pose sur le ciel pendant " exposure " secondes"
	StartExposure_EX camera (exposure*1000)
	WaitForEndExposure_EX camera
	GetLastImageExposure_EX camera Imga
//	SaveFIT Imga WorkDir$+NomObjet$+"_Brightstar_"+name$+"_initial"
//	BRIGHTEST_STAR Imga SeuilDetection PSFMin DemiLargeur Xcentro Ycentro
	duplicate Imga img
	GOSUB quick_brightest_star:
	close img
	errx=Xcentro-Xpos
	erry=Ycentro-Ypos
	INT errx errx
	INT erry erry
	Print "   erreur position initiale etoile " name$ " X=" errx " Y=" erry
	Print "   corrige l erreur"
	OFFSET_TELESCOPE Imga Xcentro Ycentro Xpos Ypos
	WaitForEndMoveTelescope
	CALIBRATE_TELESCOPE CIBLEAD2000 CIBLEDEC2000
	close imga

	print "   lancement d une pose sur le ciel pendant " exposure " secondes"
	StartExposure_EX camera (exposure*1000)
	WaitForEndExposure_EX camera
	GetLastImageExposure_EX camera Imgb
//	BRIGHTEST_STAR Imgb SeuilDetection PSFMin DemiLargeur Xcentro Ycentro
	duplicate Imgb img
	GOSUB quick_brightest_star:
	close img
	errx=Xcentro-Xpos
	erry=Ycentro-Ypos
	INT errx errx
	INT erry erry
	Print "   erreur position finale etoile " name$ " X=" errx " Y=" erry
//	SaveFIT Img WorkDir$+NomObjet$+"_Brightstar_"+name$+"_final"
	close Imgb
	CLEARIMGWINDOWS

return
# 296 "<stdin>" 2

# 1 "./lib/recaleAstrometrieAllSky-et-precis.pgm" 1

# 1 "./lib/generalSubroutine.pgm" 1

# 99 "./lib/generalSubroutine.pgm"

# 2 "./lib/recaleAstrometrieAllSky-et-precis.pgm" 2

RecaleAllSkyAstrometrieChercheur:
	if (CameraChercheurPresente=0) then
		print "Attention pas de chercheur"
		resultat_astrometrie_absolue=0
		resultat_allsky=0
		return
	ENDIF
	Print "Chercheur: Procedure Astrometrie allsky"
	AstrometrieName$="Chercheur"
	CameraAllSky=CameraChercheur
	exposureAllSky=10
	MaxStarImg=30
	MaxStarCat=30
	Field=20
	Cat$="GSC-ACT"
	Chem$=sDirCatalogue$+Cat$
	Xpos=ChercheurPosXBin
	Ypos=ChercheurPosYBin
	PolyDegAstroPrecis=1
	GOSUB RecaleAllSkyAstrometrie:
return

RecaleAllSkyAstrometrieChamp:
	Print "Champ: Procedure Astrometrie alsky"
	AstrometrieName$="FIELD-1"
	CameraAllSky=CameraChamp
	exposureAllSky=18
	MaxStarImg=30
	MaxStarCat=30
	Field=2
	Cat$="UCAC 2/3/4"
	Chem$=sDirCatalogue$+"UCAC4"
	Xpos=fentePosX
	Ypos=fentePosY
	PolyDegAstroPrecis=1
	GOSUB RecaleAllSkyAstrometrie:
return

RecaleAllSkyAstrometrie:

	CLEARIMGWINDOWS
	print "   -Pose d astrometrie sur le ciel pendant " exposureAllSky " secondes"
	StartExposure_EX CameraAllSky (exposureAllSky*1000)
	WaitForEndExposure_EX CameraAllSky
	GetLastImageExposure_EX CameraAllSky ImgAstrometrie		
	SaveFIT ImgAstrometrie WorkDir$+AstrometrieName$

	
	print "   -debut astrometrie ALLSKY"
	FIND_ALLSKY_POSITION ImgAstrometrie MaxStarImg MaxStarCat Field Cat$ Valid
	resultat_allsky=valid
	IF (resultat_allsky=1) THEN
		PRINT "     -reconnaissance ALLSKY reussie, recalage telescope"
	ELSE
		PRINT "     -echec reconnaissance ALLSKY"
		CLEARIMGWINDOWS
		resultat_astrometrie_absolue=0
		return
	ENDIF

	print "   -debut astrometrie precise"
	GETSIZEPIXX  ImgAstrometrie  PIXX
	GETSIZEPIXY  ImgAstrometrie  PIXY
	GETBINX  ImgAstrometrie  BinX
	GETBINY  ImgAstrometrie  BinY
	TAILLEX=PIXX*BinX
	TAILLEY=PIXY*BinY
	GETFOCUS  ImgAstrometrie  FOCALE
	getalpha ImgAstrometrie alpha
	getDelta ImgAstrometrie delta
	GETREPDIRHEADER  ImgAstrometrie  Dir
	EtalonAstrometrieAuto ImgAstrometrie Cat$ FOCALE TailleX TailleY alpha delta MaxStarCat MaxStarImg Dir PolyDegAstroPrecis Chem$ resultat_astrometrie_absolue

	// si la reconnaissance a reussit, on repointe,  sinon rien a faire
	IF (resultat_astrometrie_absolue=1) THEN
		print "      -reussite astrometrie precise, on recalibre"
		GetImg_XY_TO_RADDEC ImgAstrometrie Xpos Ypos Alphafente Deltafente errorNo
		// calcul et affiche l erreur
		errAlpha=Alphafente-AlphaObjet
		ABS errAlpha errAlpha
		RAD_TO_DEC  errAlpha errAlphaCoord$
		errDelta=Deltafente-DeltaObjet
		ABS errDelta errDelta
		RAD_TO_DEC  errDelta errDeltaCoord$
		print "         erreur RA=" errAlphaCoord$ " DEC=" errDeltaCoord$
		print "      -recalibre telescope"
		CALIBRATE_TELESCOPE Alphafente Deltafente
		delay 500
		waitforenddelay
		print "     -repointe cible"
		MoveTelescope AlphaObjet DeltaObjet
		WaitForEndMoveTelescope
		print "   attente rattrage entrainement horaire"
		delay DelayRepriseRA
		waitforenddelay
	ENDIF
	
return



# 297 "<stdin>" 2

# 1 "./lib/check_coord_cibles.pgm" 1
Check_coord_cibles:

Print "Verification des coordonnes des cibles"
Print "------------------------"
for i=1 NbCibles
	if Alpha[i]$="undef" THEN
		Print NomObjet[i]$
		Print Comment[i]$
		Print "Coordonnee objet non definie, utilisation de la base de Prism"
		getobjectcoord NomObjet[i]$ alpha delta
		RAD_TO_RA  alpha alpha$
		Print "alpha=" alpha$
		RAD_TO_DEC delta delta$
		Print "delta=" delta$
		alpha[i]$=alpha$
		delta[i]$=delta$		
	ELSE
		Print NomObjet[i]$
		print "Alpha:" alpha[i]$
		print "Delta:" delta[i]$ 
	ENDIF
 
 print "-----------------------------------------"
next i

return
# 298 "<stdin>" 2

# 1 "./lib/finSeance.pgm" 1
finSeance:
	print "-------------------------------------------------"
	print "Fin de seance"
	print "stop entrainment horaire"
	STOPTELESCOPE

	IF (coupole=1) then
		print "fermeture du dome"
		CLOSE_DOME
	ENDIF

	IF (ActiveFlatLISALHIRESFinSession=1) then
		GOSUB acquisition-FLAT-LISA_LHIRES:
		REM on ne fait les flat que une fois par lancement du script..
		ActiveFlatLISALHIRESFinSession=0
	endif

    ///  Telescope ///	
	IF (ActiveParkingTelescope=1) then
		print "parking du telescope"
		
		STR_RAD_TO_RA ParkHa HH$ MM$ SS$
		STR_RAD_TO_DEC ParkDe DD$ DM$ DS$
		PRINT "    Angle horaire = " HH$ "h " MM$ "m " SS$ "s"
   	    PRINT "    Declinaison   = " DD$ "d " DM$ "m" DS$ "s"
		
		GetStdrLongitude Longitude
		NOW date
		SIDERALTIME Date Longitude TSL
		ParkRa=TSL-ParkHa
		STR_RAD_TO_RA ParkRa HH$ MM$ SS$
		PRINT "    Alpha calcule = " HH$ "h " MM$ "m " SS$ "s"

		print "    execution mouvement telescope"
		MoveTelescope  ParkRa ParkDe
		print "    attente fin mouvement telescope"
		WaitForEndMoveTelescope
		print "    arret entrainement"
		STOPTELESCOPE

	ENDIF
	
	print "  recupere position telescope"
	GET_TELESCOPE_POSITION  Alpha2000  Delta2000  Hauteur  Azimuth  AngleHor
	STR_RAD_TO_RA AngleHor HH$ MM$ SS$
	STR_RAD_TO_DEC Delta2000 DD$ DM$ DS$
	PRINT "Etat du telescope fin de seance:"
	PRINT "    Angle horaire = " HH$ "h " MM$ "m " SS$ "s"
	PRINT "    Declinaison   = " DD$ "d " DM$ "m" DS$ "s"
	STR_RAD_TO_DEC Hauteur DD$ DM$ DS$
	print "    Hauteur       = " DD$ "d " DM$ "m" DS$ "s"

	
	/// Camera ///
	gosub set_cooling_camera_off:

	if (soleil_levee=1) THEN
	    // On ferme les camera que quand il fait jours
		IF (ActiveCoupureCameraFinSession=1) then
			
			Print "Attente rechauffement camera avant coupure alimentation en millisec=" DurationAttenteAvantCoupeCameraMillis
			delay DurationAttenteAvantCoupeCameraMillis
			WAITFORENDDELAY

			print "Fermeture des panneaux cameras"
			CLOSE_CCD_CAMERA_EX CameraChamp
			CLOSE_CCD_CAMERA_EX CameraSpectre
			if (CameraChercheurPresente=1) then
				// commente car l init camera chercheur est bugue dans PRISM V10
				//CLOSE_CCD_CAMERA_EX CameraChercheur
			ENDIF

			Print "Attente avant coupure alim camera"
			delay 5000
			WAITFORENDDELAY
			
			print "Coupure alimentation camera guidage"
			parm$=PythonScriptControlBox$+" 1=0"
			EXECEXTERNAL   pathPythonInterpreter$ parm$
			
			print "Coupure alimentation camera eShel"
			parm$=PythonScriptControlIPX800$+"  5=0"
			EXECEXTERNAL   pathPythonInterpreter$ parm$

			Print "Attente apres coupure alim camera"
			delay 5000
			WAITFORENDDELAY

			CLEARIMGWINDOWS
			
		ENDIF
	ENDIF

	GOSUB GeneNextLSTTarget:
	GOSUB FermeFichierLog:

	
	if (soleil_levee=1) THEN
		print "arret du script ici, il fait jours"
		END
	ENDIF
	
RETURN

acquisition-FLAT-LISA_LHIRES:

	Print "Realisation des FLAT LISA/LHIRES"
	NomObjet$="FLAT"
	GOSUB setWorkDir:

	Print "   allume lampe FLAT"
	EXECEXTERNAL   pathPythonInterpreter$  PythonScriptFLATLISALHIRESOn$
	Print "   attente apres manipulation lampe " pauseAfterLightOn " secondes"
	delay pauseAfterLightOn*1000
	WaitForEndDelay
	intituleCalib$="flat"
	
	For j=1 NbFlatLISALHIRES
		STR j idCalib$
		Print intituleCalib$ " ,    debut de la pose " j "/" NbFlatLISALHIRES " duree " exposureTimeFLATLISA " secondes"
		StartExposure_EX CameraSpectre (exposureTimeFLATLISA*1000)
		WaitForEndExposure_EX CameraSpectre
		GetLastImageExposure_EX CameraSpectre img1
		
		SaveFIT Img1 WorkDir$+"flat-"+idCalib$
		Close Img1
	Next j
	print "    eteind la lampe FLAT"
	EXECEXTERNAL   pathPythonInterpreter$  PythonScriptFLATLISALHIRESOff$
RETURN
# 299 "<stdin>" 2

# 1 "./lib/acquisition_Calibration.pgm" 1


//##########################
//#        ACQUISITON      #
//##########################
Acquisition:

//Parametres
//  ->  NomObjet$
//  ->  nbExposureObjet
//  ->  exposureTimeObjet

	print "commence l aquisition de l objet=" NomObjet$
	GOSUB LampCalibOff:
	intitule$="spectre de "+NomObjet$
	exposure=exposureTimeObjet
	nbExposure=nbExposureObjet
	FileNameEnd$="OBJECT-"
	GOSUB boucleAcquisitionObjet:
RETURN

//#############################################
//# boucle d'acquisition spectre
//##############################################
boucleAcquisitionObjet:

iacqu=1
baoi:
	GOSUB testMeridien_Hauteur:
	// Si la hauteur du telescope est trop basse on passe a la calibration..
	IF HauteurPointageOK=0 THEN
		GOTO fbaoi:	
	ENDIF

	STR iacqu id$
	Print intitule$ " ,debut de la pose " iacqu "/" nbExposure " duree " exposure " secondes"
	int exposure*1000 expomilli
	StartExposure_EX CameraSpectre expomilli
	WaitForEndExposure_EX CameraSpectre
	GetLastImageExposure_EX CameraSpectre img1
	SaveFIT Img1 WorkDir$+FileNameEnd$+id$
	Close Img1

	GOSUB ReadMeteo:
	if (MeteoOK=0) then
		print "il faut mauvais temps on arrete les acquisitions au milieu"
		STOPTELESCOPE
		IF (coupole=1) then
			print "fermeture du dome"
			CLOSE_DOME
		ENDIF
		GOTO fbaoi:
	endif
	
	if iacqu<>nbExposure then
		iacqu=iacqu+1
		goto baoi:
	ENDIF

fbaoi:	
Print ""
RETURN

//#############################################
//# boucle calibration
//##############################################
boucleAcquisitionCalib:

Print "attente apres manipulation lampe " pauseAfterLightOn " secondes"
delay pauseAfterLightOn*1000
WaitForEndDelay

For j=1 nbExposureCalib
	STR j idCalib$
	Print intituleCalib$ " ,debut de la pose " j "/" nbExposureCalib " duree " exposureCalib " secondes"

	StartExposure_EX CameraSpectre (exposureCalib*1000)
	WaitForEndExposure_EX CameraSpectre
	GetLastImageExposure_EX CameraSpectre img1
	
	SaveFIT Img1 WorkDir$+FileNameEndCalib$+idCalib$
	Close Img1
Next j
Print ""
RETURN


//###########################
//# lampe calibration  off  #
//###########################
LampCalibOff:
	Print "Extinction de toutes les lampes."
	IF LampeCalibAuto=0 then
		GETYESNO "eteindre toutes les lampes" rep
	ELSE
		IF SPECTROGRAPHE$="ESHEL" then	
			SETSWITCH switchthar OFF
			delay delayswitch
			WaitForEndDelay
			SETSWITCH switchtungsten OFF
			delay delayswitch
			WaitForEndDelay
			SETSWITCH switchled OFF
			delay delayswitch
			WaitForEndDelay
			SETSWITCH switchmirroir OFF
		ELSE
			IF SPECTROGRAPHE$="LISA" then
				EXECEXTERNAL   pathPythonInterpreter$ PythonScriptNeonLISALHIRESOff$
			ELSE
				IF SPECTROGRAPHE$="LHIRES" then
					EXECEXTERNAL   pathPythonInterpreter$ PythonScriptNeonLISALHIRESOff$
				ENDIF
			ENDIF
		ENDIF
	ENDIF
RETURN

//////////////////////////////////////////////////
Calibration:
	if SPECTROGRAPHE$="ESHEL" then
		GOSUB CalibEshel:
	ELSE
		IF SPECTROGRAPHE$="LISA" then
			GOSUB CalibLISA:
		ELSE
			IF SPECTROGRAPHE$="LHIRES" then
				GOSUB CalibLHIRES:
			ENDIF
		ENDIF
	ENDIF

RETURN

//######################"
//# Calibration ESHELL #
//######################""
CalibEshel:

PRINT "allume la lampe tungsten"
SETSWITCH switchmirroir ON
delay delayswitch
WaitForEndDelay
SETSWITCH switchtungsten ON
intituleCalib$="Tungsten de "+NomObjet$
exposureCalib=exposureTimeTungsten
nbExposureCalib=nbExposureTungsten
FileNameEndCalib$="TUNGSTEN-"
GOSUB boucleAcquisitionCalib:

Print "Allume les LED"
SETSWITCH switchled ON
intituleCalib$="LED de "+NomObjet$
exposureCalib=exposureTimeLED
nbExposureCalib=nbExposureLED
FileNameEndCalib$="LED-"
GOSUB boucleAcquisitionCalib:

Print "Allume la lampe Thorium-Argon"
SETSWITCH switchled OFF
delay delayswitch
WaitForEndDelay
SETSWITCH switchtungsten OFF
delay delayswitch
WaitForEndDelay
SETSWITCH switchthar ON
intituleCalib$="Thorium Argon de "+NomObjet$
exposureCalib=exposureTimeThar
nbExposureCalib=nbExposureThar
FileNameEndCalib$="CALIB-"
GOSUB boucleAcquisitionCalib:
GOSUB LampCalibOff:

RETURN

//####################
//# Calibration LISA #
//####################
CalibLISA:
	Print "Allume la lampe Neon"
	IF LampeCalibAuto=0 then
		GETYESNO "allumer la lampe neon" rep
	ELSE
		EXECEXTERNAL   pathPythonInterpreter$ PythonScriptNeonLISALHIRESOn$
	ENDIF

	intituleCalib$="Neon long de "+NomObjet$
	exposureCalib=exposureTimeNeonLISA1
	nbExposureCalib=1
	FileNameEndCalib$="NEON-"
	GOSUB boucleAcquisitionCalib:

	GOSUB LampCalibOff:
RETURN

//######################
//# Calibration LHIRES #
//######################
CalibLHIRES:
	Print "Allume la lampe Neon"
	IF LampeCalibAuto=0 then
		GETYESNO "allumer la lampe neon" rep
	ELSE
		EXECEXTERNAL   pathPythonInterpreter$ PythonScriptNeonLISALHIRESOn$
	ENDIF
	intituleCalib$="Neon de "+NomObjet$
	exposureCalib=exposureTimeNeonLHIRES1
	nbExposureCalib=1
	FileNameEndCalib$="NEON-"
	GOSUB boucleAcquisitionCalib:

	GOSUB LampCalibOff:
RETURN


//####################################
//#  fenetre d'entrée des parametres
//####################################
EntreeParametre:
REM *****************************
resetdlgbox
adddlgbox 4 "Nom objet" NomObjet$
adddlgbox 6 "Repertoire des images" Directory$
adddlgbox 3 100 0 "Nombre de pose objet" nbExposureObjet
adddlgbox 2 3600 0 "Temps de pose unitaire Objet" exposureTimeObjet
adddlgbox 3 50 1 "Nombre de pose Tungsten(flat)" nbExposureTungsten
adddlgbox 2 60 0 "Temps de pose unitaire Tungsten(flat)" exposureTimeTungsten
adddlgbox 3 50 1 "Nombre de pose LED" nbExposureLED
adddlgbox 2 60 0 "Temps de pose unitaire LED" exposureTimeLED
adddlgbox 3 50 1 "Nombre de pose Thorium Argon" nbExposureThar
adddlgbox 2 60 0 "Temps de pose unitaire Thorium Argon" exposureTimeThar
adddlgbox 5 "Test hauteur mini telescope actif ?" 0
adddlgbox 2 60 0 "hauteur mini telescope en degree" HautDegMiniTelescope
adddlgbox 5 "Test passage meridien actif ?" 0
adddlgbox 3 300 0 "Nombre de boucle Globale Spectre/Calib" nbLoopProcessGlobal

REM La boîte de dialogue apparaît à l'écran
dispdlgbox result
if (result=1)
 getdlgbox NomObjet$
 getdlgbox Directory$
 getdlgbox nbExposureObjet
 getdlgbox exposureTimeObjet
 getdlgbox nbExposureTungsten
 getdlgbox exposureTimeTungsten
 getdlgbox nbExposureLED
 getdlgbox exposureTimeLED
 getdlgbox nbExposureThar
 getdlgbox exposureTimeThar
 getdlgbox testHauteurTelescope
 getdlgbox HautDegMiniTelescope
 getdlgbox testColisionMeridien
 getdlgbox nbLoopProcessGlobal
 
else
 print "Annulé !"
 exit
endif

Print "Acquisition des spectres suivit des calibrations pour le spectro eShel"
Print "Repertoire de travail : "+Directory$
Print "Objet : "+NomObjet$

RETURN

//##########################"
//# repertoire de travail #
//#########################""
setWorkDir:

NOW Cyear Cmonth Cday Chour CMinute CSecond CMillisec
STR Cyear Cyear$
STR Cmonth Cmonth$
STR Cday Cday$
STR Chour Chour$
STR CMinute CMinute$
STR CSecond CSecond$
WorkDir$=GeneralWorkDir$+Cyear$+"-"+Cmonth$+"-"+Cday$+"_"+Chour$+"h"+CMinute$+"m"+CSecond$+"\"
rem WorkDir$=GeneralWorkDir$
Print "Repertoire de travail : "+WorkDir$
CreateDir WorkDir$

RETURN

//##########################
//# test colision pilier et pointage trop bas
//########################
testMeridien_Hauteur:
  	// variable pour le resultat du test
	resultTestMeridien=0 

	// on fait ce code que si c'est active dans le general settings.
	IF testColisionMeridien=1 THEN
		// De quel côté est le télescope ?
		PIERSIDE_TEL ActualSide$
		GET_TELESCOPE_POSITION AD2000 DEC2000 Haut Azi AHor	
		// Ramene l'angle dans l' intervale [-pi/2...+pi]
		if AHor>3.1416 THEN
			AHor=AHor-6.283185
		ENDIF
		if AHor<-3.1416 THEN
			AHor=AHor+6.283185
		ENDIF
		
		print "actualSide=" ActualSide$ " AHor=" AHor

		IF ActualSide$="WEST" THEN
			// en minutes
			MiniChgMeridien=10
			MaxiChgMeridien=30
			// en radian
			MiniChgMeridien=MiniChgMeridien/60/12*3.1415
			MaxiChgMeridien=MaxiChgMeridien/60/12*3.1415
			
			// exposure en seconde
			angExposure=exposure/60/60/12*3.1415
			IF AHor>MiniChgMeridien THEN
				print "Ahor MiniChgMeridien"
				resultTestMeridien=1
			ENDIF
			
			IF (AHor+angExposure)>MaxiChgMeridien
				print "Ahor+angleExposure > MaxiChgMeridien"
				resultTestMeridien=1
			ENDIF
		ENDIF
		
		IF resultTestMeridien=1 THEN
			STOPTELESCOPE
			Print "On a passe le meridien, on repointe"
			GOSUB arret_guidage:
			IF  CalibrationAsk[iobj]=1 THEN
				//   sur un spectro eShel le passage du meridien  n'implique une calib suplementaire
				IF SPECTROGRAPHE$<>"ESHEL" then
					GOSUB Calibration:
					// relance la numerotation des poses a 1 et avec un mon modifie
					nbExposure=nbExposure-iacqu+1
					iacqu=1
					NomObjet$=NomObjet$+"-apm"
				ENDIF
			ENDIF
			GOSUB Pointe_et_gere_retournement:
			GOSUB attente_dome:
			GOSUB High_level_Centrage:
			GOSUB lance_guidage:
		ENDIF
		
	ENDIF

	HauteurPointageOK=1
	IF testHauteurTelescope=1 THEN
		GET_TELESCOPE_POSITION AD2000 DEC2000 Haut Azi AHor
		HautDeg=Haut*360.0/(3.1415*2.0)
		IF HautDeg<HautDegMiniTelescope THEN
			STOPTELESCOPE
			Print "hauteur trop faible"
			Print "hauteur actuelle: " HautDeg " degree"
			Print "hauteur limite: "  HautDegMiniTelescope " degree"
			HauteurPointageOK=0
		ENDIF
	ENDIF
	
RETURN
# 300 "<stdin>" 2

# 1 "./lib/pointe_et_gere_retournement.pgm" 1


test_retournement_necessaire:

	// De quel côté est le télescope ?
	GOSUB CalcPierSide:

	// De quel côté sera l'objet pointé ?
	PIERSIDEDEST_TEL AlphaObjet DeltaObjet SideObject$
	If SideObject$="NO ORIENTATION" then
		Now Date
		GetDistanceToMeridien AlphaObjet Date Longitude Distance
		if Distance<0 then
			SideObject$="WEST"
		EndIf
		if Distance>0 then
			SideObject$="EAST"
		EndIf
	EndIf
	Chaine$=STR_02$+SideObject$
	PRINT Chaine$

	// Faut-il faire un retournement ?
	if ActualSide$=SideObject$ then
		RetournementNecessaire=0
		PRINT STR_03$
	else
		RetournementNecessaire=1
		PRINT STR_04$
	EndIf

return

Pointe_et_gere_retournement:
// S'il faut faire un retournement, passer par la zone du type AH=+3H et DEC=45° si ObjectSide$="EAST"
//                                                             AH=-3H et DEC=45° si ObjectSide$="WEST"

if RetournementNecessaire=1 then

   AHDegagementRAD=3*PI/12
   // Temps Sidéral
   Now Date
   SideralTime Date Longitude TSL
   // DEC vas-y !
   STR_DEC_TO_RAD 45 00 00 DeltaRetournement
   
   if SideObject$="EAST" then
      // RA vas-y !
      AlphaRetournement=TSL-AHDegagementRAD
   else
      AlphaRetournement=TSL+AHDegagementRAD
   EndIf
   
   // on realise le degagement
   AlphaDest=AlphaRetournement
   DeltaDest=DeltaRetournement
   GOSUB Pointage:
      
	// on pointe l'objet
   AlphaDest=AlphaObjet
   DeltaDest=DeltaObjet
   GOSUB Pointage:
   delay 5000
   waitforenddelay
   // reconfigure l'orientation des camera suite au retournement
   GOSUB Oriente_Camera:
ELSE
	// sans retournement, on a juste a pointer.
	AlphaDest=AlphaObjet
	DeltaDest=DeltaObjet
	GOSUB Pointage:
    delay 5000
    waitforenddelay

EndIf


return
   
# 301 "<stdin>" 2

# 1 "./lib/pointe_etoile_brillante_proche.pgm" 1


Pointe_etoile_brillante_proche:

	//#je recupere les coor ou je veux aller !
	GET_TELESCOPE_POSITION CIBLEAD2000 CIBLEDEC2000 Haut Azi AHor
   // Pointe un étoile d'une certaine magnitude le plus proche possible
   FIND_GSCACT_STAR CIBLEAD2000 CIBLEDEC2000 MagMin MagMax Radius NbEtoile Distance ListeAD ListeDEC ListMagn
   Print "NbEtoiles de dégagement =" NbEtoile 
   For i=1 NbEtoile
      RAD_TO_RA  ListeAD[i] alpha$    
      RAD_TO_DEC ListeDEC[i] delta$    
      str i i$
      STR Distance[i] distance$
      Print i$ "   Distance(°)=" distance$ "  RA=" alpha$ " DEC=" delta$  " Magnitude=" ListMagn[i]
   next i

   // Prendre celle qui ne demande pas de retournement et la pointer :
   i=0
   If NbEtoile>0 then
      Test_Degagement:
      i=i+1
	  STR i i$
      PIERSIDEDEST_TEL ListeAD[i] ListeDEC[i] SideObject$
      If SideObject$=ActualSide$ then
		 Chaine$="Etoile n°"+i$+" ne demande pas de retournement ! Retenue !"
	     PRINT Chaine$ 
	  Else
	     Chaine$="Etoile n°"+i$+" demande un retournement ! Non retenue !"
	     PRINT Chaine$
         Goto Test_Degagement:
      EndIf
   Else
      PRINT STR_23$
   EndIf
   AlphaDest=ListeAD[i]
   DeltaDest=ListeDEC[i]
   GOSUB Pointage:
return
# 302 "<stdin>" 2

# 1 "./lib/guidage.pgm" 1
arret_guidage:
	// Arrêt du guidage
	PRINT "Arrêt de l'autoguidage sur Consigne"
	STOPGUIDE_EX CameraChamp CCDNum
return
	
lance_guidage:
	PRINT "autoguidage"
	GOSUB init_param_guiding:
	GOSUB find_exposure_time_guide_star:
	GOSUB center_guide_star:
	If Valid=2 then
		PRINT "   Autoguidage de centrage échoué" 
		PRINT message$
		return
	Endif
	If Valid=0 then
		print "   centrage OK"
	endif

	GOSUB reduce_agressivity_guide:
	GOSUB start_exposure_field_save:
	GOSUB start_final_guide_star:
	
	// Valid           : 0 = OK  1 = Guidage en cours  2 = Pas d'etoile Guide, probleme d'initialisation de guidage
	If Valid=2 then
		PRINT "   Autoguidage final échoué" 
		PRINT message$
		return
	Endif
	If Valid=0 then
	   print "   Autoguidage definitif en cours"
	endif
	
return

//////////////////////
/ parameter of guiding
///////
init_param_guiding:
	NumCam=CameraChamp
	CCDNum=1
	DelayACQSec=1
	WindowSize=60
	CentroSize=30
	StarThresADU=20
	RaMin=0
	RaMax=500
	DecMin=0
	DecMax=500
	Backlash=0
	CurrentDEC=0
	AlarmEnabled=0
	GuidePosX=consigneX
	GuidePosY=consigneY
	DeltaMoveFashion=0
	SaveImagettes=0
	DirSaveImg$="c:\ccd"
	AllFrame=0
	MinADUguidage=3500
	//WindowAllFrame definis dans general setting
return


///////////////////////////////////////
// center the guide star
///////////////////////////////////
center_guide_star:
	AgressRA=1
	AgressDEC=1
	Print "   lance centrage rapide: agressivite RA,DEC=" AgressRA "," AgressDEC
	print "      WindowSize=" WindowSize
	print "      Centrosize=" CentroSize
	print "      AllFrame=" AllFrame 
	print "      WindowAllFrame=" WindowAllFrame
	//SETWINDOW_EX CameraChamp X1 Y1 X2 Y2
	STARTGUIDECONSIGNE NumCam CCDNum ExpTime/1000 DelayACQSec WindowSize CentroSize StarThresADU AgressRA AgressDEC RaMin RaMax DecMin DecMax Backlash CurrentDEC AlarmEnabled DeltaMoveFashion GuidePosX GuidePosY SaveImagettes DirSaveImg$ AllFrame WindowAllFrame Valid message$
	PRINT "   centrage stop"
	STOPGUIDE_EX NumCam CCDNum
return

/////////////////////
// reduce agressivity of guiding, according spectrograph type and guide star type
/////////////////////	
reduce_agressivity_guide:
	if (activeGuideAggressiviteRalentie=1) then	
		if SPECTROGRAPHE$="ESHEL" then
			print "   agressivite pour guidage sur fibre"
			AgressRA=0.3
			AgressDEC=0.3
		else
			if OrientationFente=OriFenteHorizon then
				AgressRA=1
				AgressDEC=0.3
			else
				AgressRA=0.3
				AgressDEC=1
			endif
		endif
	endif
return

/////////////////////
// long exposure on the field to get history
////////////////////
start_exposure_field_save:
	print "   Pose sur le champ pour sauvegarde"
	StartExposure_EX CameraChamp 3000
	WaitForEndExposure_EX CameraChamp
	GetLastImageExposure_EX CameraChamp ImgChamp
	SaveFIT ImgChamp WorkDir$+"FIELD-2.fits"
	CLEARIMGWINDOWS
return

///////////////////////
// final guiding
//////////////////////	
start_final_guide_star:
	print  "   lance autoguidage final Agressivite RA=" AgressRA " DEC=" AgressDEC
	print "      WindowSize=" WindowSize
	print "      AllFrame=" AllFrame 
	print "      WindowAllFrame=" WindowAllFrame
	//SETWINDOW_EX CameraChamp X1 Y1 X2 Y2
	STARTGUIDECONSIGNE NumCam CCDNum ExpTime/1000 DelayACQSec WindowSize CentroSize StarThresADU AgressRA AgressDEC RaMin RaMax DecMin DecMax Backlash CurrentDEC AlarmEnabled DeltaMoveFashion GuidePosX GuidePosY SaveImagettes DirSaveImg$ AllFrame WindowAllFrame Valid message$
return
	
///////////////////
///// determination du temps de guidage optimum
//////////////////
find_exposure_time_guide_star:
	print "Determine le temps de pose pour le guidage"
	X1=binCameraChamp*(consigneX-WindowEvalGuideStar)
	INT X1 X1
	Y1=binCameraChamp*(consigneY-WindowEvalGuideStar)
	INT Y1 Y1
	X2=binCameraChamp*(consigneX+WindowEvalGuideStar)
	INT X2 X2
	Y2=binCameraChamp*(consigneY+WindowEvalGuideStar)
	INT Y2 Y2

	print "  fenetrage camera guidage demiFenetre=" WindowEvalGuideStar " X1=" X1 " Y1=" Y1 " X2=" X2 " Y2=" Y2
	SETWINDOW_EX CameraChamp X1 Y1 X2 Y2
	
	// si on guide sur la cible, on a besoin de plus de flux une fois dans la fente..
	if GuideMode$="Coord"
		coefMinADUguidage=1
	else
		coefMinADUguidage=4		
	endif
	
	// exposition max du guidage en ms
	MaxExpTime=10000
	
	// temps de guidage de depart en millisec
	ExpTime=10
boucle_temps_guidage:	
	StartExposure_EX CameraChamp ExpTime
	WaitForEndExposure_EX CameraChamp
	GetLastImageExposure_EX CameraChamp ImgGuide
	//GETBACKGROUND  ImgGuide  Background  Sigma
	//OFFSET ImgGuide -Background
	STAT  ImgGuide   Moyenne  MoyenneQuadratique  Ecarttype  Max  Min  Flux  Mediane
	max=max-OffsetValueCameraChamp
	if (max<1) then
		max=1
	endif
	print "   pose de " expTime/1000 " secondes  donne une etoile a " max " ADU"
	if (max>(MinADUguidage*coefMinADUguidage)) then
		goto ok_flux_guide_g:
	endif
	// pas assez de flux, on augmente le temps
	if ExpTime>MaxExpTime then
		goto ok_flux_guide_g:
	endif
	ExpTime=ExpTime*3
	goto boucle_temps_guidage:
		
ok_flux_guide_g:

	// ajuste le temps exposition pour obtenir a peut pret un flux "MinADUguidage"
	Exptime=ExpTime*coefMinADUguidage*MinADUguidage/max
	INT Exptime Exptime
	
	if ExpTime>MaxExpTime then
		ExpTime=MaxExpTime
		print "maximum de temps de guidage utilise"
	endif
	print "   On choisit un temps de pose de guidage de =" ExpTime/1000 " secondes"
	CLEARIMGWINDOWS
	SetWindowFullFrame_Ex CameraChamp
	
return

///////////////////////
// etoile guide
///////////////////////
determine_etoile_guide:
	if GuideMode$="Coord"
		print "etoile guide imposée"
//		consigneX=243
//		consigneY=295
//		activeGuideAggressiviteRalentie=1

		alphaEtoileGuide$=RAGuide$
		deltaEtoileGuide$=DECGuide$
		RA_TO_RAD  alphaEtoileGuide$ alphaEtoileGuide
		DEC_TO_RAD  deltaEtoileGuide$ deltaEtoileGuide
		GETIMG_RADDEC_TO_XY  ImgAstrometrie  alphaEtoileGuide  deltaEtoileGuide  XGuideTh  YGuideTh  Erreur
		GETIMG_RADDEC_TO_XY  ImgAstrometrie  AlphaObjet  DeltaObjet  XCibleTh  YCibleTh  Erreur	
		consigneX=fentePosX+XGuideTh-XCibleTh
		consigneY=fentePosY+YGuideTh-YCibleTh
		activeGuideAggressiviteRalentie=0
		print "   L etoile guide n est pas la cible, on guide normalement"
	ELSE
		print "   La cible est l'etoile de guidage on va guider doucement"
		activeGuideAggressiviteRalentie=1
		consigneX=fentePosX
		consigneY=fentePosY
	ENDIF
	
	INT consigneX consigneX
	INT consigneY consigneY
	print "consigne X,Y=" consigneX "," consigneY
return

// test de guidage par script
// STARTGUIDECONSIGNE NumCam CCDNum ExpTime DelayACQSec WindowSize CentroSize StarThresADU AgressRA AgressDelta RaMin RaMax DecMin DecMax Backlash CurrentDEC
//                    AlarmEnabled  DeltaMoveFashion ConsignePosX ConsignePosY SaveImagettes DirSaveImg AllFrame WindowAllFrame Valid message$
//
//In
//1  NumCam          : Numero de la camera : principale, secondaire ou tertiaire
//2  CCDNum          : Numero de ccd de guidage 0=principal 1=CCD auxiliaire
//3  ExpTime         : Temp de pose en sec
//4  DelayACQSec     : Delai d'acquisition en seconde
//5  WindowSize      : Demi Taille de la fenetre de guidage (pixels)
//6  CentroSize      : Demi Taille pour le centroide (pixels)
//7  StarThresADU    : Seuil de l'etoile, si pas d'etoile au dessus du seuil, = erreur pas de guidage
//8  AgressRA        : Agressivite RA  (0-1)
//9  AgressDelta     : Agressivite DEC (0-1)
//10 RaMin           : Nbre de pixels Min de deplacement en RA (Pixels)
//11 RaMax           : Nbre de pixels Max de deplacement en RA (Pixels)
//12 DecMin          : Nbre de pixels Min de deplacement en DEC (Pixels)
//13 DecMax          : Nbre de pixels Max de deplacement en DEC (Pixels)
//14 Backlash        : Nbre de pixel de Backlash
//15 CurrentDEC      : Delta courant (ignoré si codeurs sont actifs telescope actifs)
//16 AlarmEnabled    : 0 = Pas d'alarmes  1 = Alarmes
//17 DeltaMoveFashion: 0 = Normal, 1 pas de mvt delta, 2 Mvt positifs seulement, 3 Mvt Negatifs seulements
//18 ConsignePosX    : Position consigne suivant X
//19 ConsignePosY    : Position consigne suivant Y
//20 SaveImagettes   : 1 = Sauver - 0 = Pas sauver
//21 DirSaveImg      : Répertoire de sauvegarde des imagettes si OK
//22 AllFrame        : Guidage sur toute l'image.
//23 WindowAllFrame  : Taille de la fenetre de recherche autour de la consigne  (evite d'aller chercher n'importe quoi dans l'image ALL Frame)
//
//Out
//24 Valid           : 0 = OK  1 = Guidage en cours  2 = Pas d'etoile Guide, probleme d'initialisation de guidage
//25 Message$        : Message d'erreur, si existant
# 303 "<stdin>" 2

# 1 "./lib/quick_brightest_star.pgm" 1
quick_brightest_star:
	HEIGHT img h 
	Width  img l 
	DETOURAGEEXT  img  5  5  (l-5)  (h-5)  0 
	median img 1 3 
	stat  img  Moyenne  MoyenneQuadratique  Ecarttype  Max  Min  Flux  Mediane  
	GETMINMAX  1  l-1  1  h-1  img  Xmin  Ymin  Valmin  Xmax  Ymax  Valmax  
	print "   GETMINMAX: Xmax=" Xmax " Ymax=" Ymax
	//CENTROIDEGAUSS  img  Xmax  Ymax  DemiLargeur  Xcentro  Ycentro  SigW  SigH  Angle  Flux  OMC  HOMC  ErrFlux
	XCENTRO=Xmax
	YCENTRO=Ymax
	CENTROADU=Valmax
	Print "   Brightest star: X="  XCENTRO  " Y=" YCENTRO 

return
# 304 "<stdin>" 2

# 1 "./lib/find_best_guide_star.pgm" 1
find_best_guide_star:
	print "find_best_guide_star:"
	HEIGHT img h 
	Width  img l
	Resol=3
	maxDynamique=40000
	w=10

	DETOURAGEEXT  img  w  w  (l-w)  (h-w)  0
	GETSTARLIST  Img  Resol  NbStars  ListX  ListY  ListFlux
	print "   Nbstar=" NbStars
	
	iiii=0
boucle_cherche_good_star:
//	GETPIXELVALUE  Img  ListX[iiii]  ListY[iiii]  Max
	X1=ListX[iiii]-w
	INT X1 X1
	Y1=ListY[iiii]-w
	INT Y1 Y1
	X2=ListX[iiii]+w
	INT X2 X2
	Y2=ListY[iiii]+w
	INT Y2 Y2
	STATWINDOW  Img  X1 Y1 X2 Y2  Moyenne  MoyenneQuadratique  Ecarttype  Max  Min  Flux  Mediane
	print "etoile i=" iiii " Max=" Max
	if Max<maxDynamique then
		print "etoile i=" iiii
		XCENTRO=ListX[iiii]
		YCENTRO=ListY[iiii]
		CENTROADU=Max
		Goto OK_good_star_find:
	endif
next_star_cherche_best:
	iiii=iiii+1
	if (iiii=NbStars) then
		print "**********pas d etoile de guidage trouve"
		goto OK_good_star_find:
	endif

	goto boucle_cherche_good_star:

OK_good_star_find:
	Print "   Chosen star: X="  XCENTRO  " Y=" YCENTRO  "  max value ADU=" Max  "i=" iiii
//	GETEXPTIME  Img  exposureImg
//	Print "   exposure=" exposureImg

return
# 305 "<stdin>" 2

# 1 "./lib/attente_dome.pgm" 1
attente_dome:
	if coupole<>1 then
		GOTO S13285:
	ENDIF

	Print "attente 1 minute max que le dome arrive"
	for d=1 60
		GET_DOME_POS  Azimuth  Status Statusb
		IF status=1 then
			
			GOTO S13285:
		ENDIF
		delay 1000
		waitforenddelay
	next d
S13285:
	Print "    Fin d attente:  duree: " d " sec"
return
# 306 "<stdin>" 2

# 1 "./lib/affiche_planning.pgm" 1
Affiche_planning:
	DureeJour=24*60*60
	if SPECTROGRAPHE$="ESHEL" then
		DureeCalib=60*7.0
	else
		DureeCalib=30
	endif
	DureePointage=60*3
	DureeDownload=3
Print "***********************************************"
Print "Planning de la seance d observation"

now Date_start
pdate=Date_start

DATETOSTR  pdate pdate$
Print "Commence a : " pdate$

for  ip=1 NbCibles
	STR ip ip$
	print
	Print "cible no " ip$ 
	
	// calcul debut de pose
	RA_TO_RAD alpha[ip]$ alphaObjet
	DEC_TO_RAD Delta[ip]$ deltaObjet
	NomObjet$=NomObjet[ip]$
	AltName$=AltName[ip]$
	Comment$=Comment[ip]$
	STR nbExposureObjet[ip] nbex$
	STR exposureTimeObjet[ip] sec$
	DATETOSTR  pdate pdate$

	Print pdate$ " : Pointe cible " NomObjet$ "  " AltName$ " " Comment$		

	date=pdate
	gosub test_visibilitee:
	if OK_visible=0 THEN
		goto PlanningCibleSuivante:
	ENDIF

	if CalibrationAsk[ip]=2 THEN
		print "   -calibration initiale " pdate$
		pdate=pdate+DureeCalib/DureeJour
		DATETOSTR  pdate pdate$
	ELSE
		print "   -fin de pose a " pdate$
	ENDIF
	
	// duree pointage et affinage pointage
	pdate=pdate+DureePointage/DureeJour
	
	DATETOSTR  pdate pdate$
	print "   -debut pose a  " pdate$ " pauses " nbex$ "x" sec$ " secondes"
	// la pose est finie
	if nbExposureObjet[ip]<>0 THEN
		pdate=pdate+nbExposureObjet[ip]*(exposureTimeObjet[ip]+DureeDownload)/DureeJour
	else
		pdate=pdate+1*(exposureTimeObjet[ip]+DureeDownload)/DureeJour
	endif
	
	DATETOSTR  pdate pdate$
	GetDistanceToMeridien alphaObjet pdate Longitude Ha
	STR Ha Ha$
	GETHEIGHT alphaObjet deltaObjet pdate Longitude latitude hauteur
	RAD_TO_DEC   hauteur hauteur$	
	print "   -fin de pose a "  pdate$
	print "      -angle horaire= " Ha$ " heures"
	print "      -hauteur      = " hauteur$

	if CalibrationAsk[ip]<>0 THEN
		print "   -calibration finale a " pdate$
		pdate=pdate+DureeCalib/DureeJour
		DATETOSTR  pdate pdate$
	ELSE
		print "   -fin de pose a " pdate$
	ENDIF
	print

PlanningCibleSuivante:
	
next ip

print
print "-------------------------fin planning---------------------------------"
print
return
# 307 "<stdin>" 2

# 1 "./lib/meteo.pgm" 1
// lecture des parametres de la station meteo Sentinel
ReadMeteo:

rem Print "Donnees de la station meteo Sentinel:"
pathSentinel$="C:\Users\DELL\Documents\Sentinel\Datas\infodata.txt"
Open_FileTxt_For_Read fichier pathSentinel$

for i=1 7
	ReadFileTXT fichier ligneDummy$
next i

ReadFileTXT fichier ligneTempExt$
CUTSTR ligneTempExt$ "=" 2 out$
val out$ TempExt
rem print "tempExt=" out$

ReadFileTXT fichier ligneHumidity$
CUTSTR ligneHumidity$ "=" 2 out$
val out$ Humidity
rem print "Humidity=" out$

ReadFileTXT fichier ligneDummy$
ReadFileTXT fichier ligneDummy$

ReadFileTXT fichier ligneTempSkyIR$
CUTSTR  ligneTempSkyIR$  "="  2  out$
val out$ TempskyIR
rem print "TempskyIR=" out$

ReadFileTXT fichier ligneTempDetectorIR$
CUTSTR ligneTempDetectorIR$ "=" 2 out$
val out$ TempDetectorIR
rem print "TempDetectorIR=" out$

ReadFileTXT fichier ligneRainFall$
CUTSTR ligneRainFall$ "=" 2 out$
if Out$="No" then
		RainFall=0
ELSE
		RainFall=1
ENDIF
rem print "RainFall=" out$

ReadFileTXT fichier ligneWindSpeedGust$
CUTSTR ligneWindSpeedGust$ "=" 2 out$
val out$ WindSpeedGust
rem print "WindSpeedGust=" out$

ReadFileTXT fichier ligneDummy$
ReadFileTXT fichier ligneDummy$
ReadFileTXT fichier ligneDummy$
ReadFileTXT fichier ligneDummy$

ReadFileTXT fichier ligneLightLevel$
CUTSTR ligneLightLevel$ "=" 2 out$
val out$ LightLevel
rem print "LightLevel=" out$

tempCiel=TempSkyIR-TempExt
STR tempCiel tempCiel$
rem print "calcul temperature ciel =" tempCiel$

////////////////////////
if (tempCiel<LimitTempCiel) then
	if RainFall=0 then
		if LightLevel>LimitMagnitudeCiel
			BeauTemp=1
		ELSE
			BeauTemp=0
		ENDIF
	ELSE
		BeauTemp=0
	ENDIF
ELSE
	BeauTemp=0
ENDIF	

// Beautemp est obtenus en regardant que la derniere valeur du  Sentinel.
if BeauTemp=1 then
	CompteurBeauTemp=CompteurBeauTemp+1
ELSE
	CompteurBeauTemp=0
ENDIF

// MeteoOK donne un résultat filtree..
if CompteurBeauTemp>ValMinBelleMeteo then
	rem NOW Annee Mois Jour Heure Minutes Secondes MS
	rem PRINT "Nous sommes le " Jour "/" Mois "/" Annee "à " Heure ":" Minutes ":" Secondes "," MS "( en UT ! )"
	rem Print "Il fait beau depuis un moment.. On va pouvoir observer"
	MeteoOK=1
else
	MeteoOK=0
	IF (BeauTemp=1) then
		rem NOW Annee Mois Jour Heure Minutes Secondes MS
		rem PRINT "Nous sommes le " Jour "/" Mois "/" Annee "à " Heure ":" Minutes ":" Secondes "," MS "( en UT ! )"
		rem Print "Si le beau temps se maintien, on pourra observer"
	ELSE
		rem Print "Il ne fait pas assez beau pour observer"
	ENDIF
ENDIF

CLOSEFILETXT  fichier
return

BoucleAttendBeauTemp:

	GOSUB ReadMeteo:
	DELAY 60000
	WAITFORENDDELAY
	
	if MeteoOK=0 THEN
		GOTO BoucleAttendBeauTemp:
	ENDIF

	NOW Annee Mois Jour Heure Minutes Secondes MS
	PRINT "Nous sommes le " Jour "/" Mois "/" Annee "à " Heure ":" Minutes ":" Secondes "," MS "( en UT ! )"
	print "Il faut beau"
	
return
# 308 "<stdin>" 2

# 1 "./lib/test_visibilitee.pgm" 1
test_visibilitee:

// argument:  date AlphaObjet  DeltaObjet  NomObjet$ AltName$ Comment$
// sortie:    OK_visible

	GetStdrLongitude Longitude
	GetStdrLatitude Latitude

	GetDistanceToMeridien AlphaObjet date Longitude Ha
	STR Ha Ha$
	GETHEIGHT AlphaObjet DeltaObjet date Longitude latitude hauteur
	hauteur=hauteur*180/3.1415
	print "Test de visibilitee de " NomObjet$ " " AltName$ " " comment$
	print "     -angle horaire= " Ha$ " heures"
	print "     -hauteur      = " hauteur " degre"

	OK_visible=1
	if hauteur<HautDegMiniTelescope then
		print "     *** La cible " NomObjet$ " " Comment$ " est trop basse"
		OK_visible=0
		raisonEchec$="trop basse"
		GOSUB LogObservationEchec:
		return
	endif
	
	if hauteur>HautDegMaxTelecope then
		print "     *** La cible " NomObjet$ " " Comment$ " est trop haute"
		OK_visible=0
		raisonEchec$="trop haute"
		GOSUB LogObservationEchec:
		return
	endif

return

test_levee_soleil:
	now Date
	DATETOSTR  Date  Date$
	GetRaDecSun Date AlphaS DeltaS ElevationSun
	ElevationSun=ElevationSun*180/3.1415
	if (ElevationSun>ElevationMaxSun) then
		Print "******************************************************"
		Print "Le soleil est quasiment levee, elevation=" ElevationSun 
		Print "On arrete la seance ici"
		WriteFileTxt fileLog Date$+": Le soleil est quasiment levee, On arrete la seance ici"
		soleil_levee=1
	else
		Print "Le soleil ne nous gene pas encore elevation=" ElevationSun
		soleil_levee=0
	endif
	return	
# 309 "<stdin>" 2

# 1 "./lib/liste_etoile_cat.pgm" 1
liste_etoile_cat_chercheur:
	focale=focaleCameraChercheur
	SizeX=WidthImgCameraChercheur
	SizeY=HeightImgCameraChercheur
	TaillePixX=TaillePixXCameraChercheur 
	TaillePixY=TaillePixYCameraChercheur

	MagMin=0
	MagMax=9

	// pour un test uniquement
	getobjectcoord "BSC7796" AlphaObjet DeltaObjet
	RAD_TO_RA  AlphaObjet alpha$    
	RAD_TO_DEC DeltaObjet delta$    
	Print "Cible   RA=" alpha$ " DEC=" delta$
	GOSUB liste_etoile_cat:
return

liste_etoile_cat_champ:
	focale=focaleCameraChamp
	SizeX=WidthImgCameraChamp
	SizeY=HeightImgCameraChamp
	TaillePixX=TaillePixXCameraChamp
	TaillePixY=TaillePixYCameraChamp
	
	
	

	// pour un test uniquement
	getobjectcoord "hd170061" AlphaObjet DeltaObjet
//	getobjectcoord "bsc6956" AlphaObjet DeltaObjet

	MagObjet=6
	STR MagObjet MagObjet$
	
	RAD_TO_RA  AlphaObjet alpha$    
	RAD_TO_DEC DeltaObjet delta$
	
	Print "Cible   RA=" alpha$ " DEC=" delta$ " magnitude=" MagObjet$
	
	MagMin=0
	MagMax=MagObjet+2
	GOSUB liste_etoile_cat:
return

  
liste_etoile_cat:

	rem Nom du catalogue a utiliser
	// Catalog that can be used
	Cat[1]$="GSC"
	Cat[2]$="USNO SA"
	Cat[3]$="USNO A1"
	Cat[4]$="USNO A2"
	Cat[5]$="Hipparcos"
	Cat[6]$="SAO"
	Cat[7]$="BSC"
	Cat[8]$="Tycho1"
	Cat[9]$="GSC-ACT"
	Cat[10]$="Tycho2"
	Cat[10]$="UCAC 2/3/4"

	Catalog$=Cat[10]$

	Coul$="R" 
	FactC=1
	Now DateUTC

	ChampX=SizeX*TaillePixX/focale/1000
	RAD_TO_DEC ChampX ChampX$
	ChampY=SizeY*TaillePixY/focale/1000
	RAD_TO_DEC ChampY ChampY$
	Print "Champ " ChampX$ " x " ChampY$
	
	
	// Distance d'exclusion
	DistAS=0

	GetStarListCat Catalog$ focale TaillePixX TaillePixY AlphaObjet DeltaObjet Coul$ sDirCatalogue$ FactC MagMin MagMax DateUTC SizeX SizeY DistAS NbEtoile ListeAD ListeDEC ListMagn

	Print "NbEtoile=" NbEtoile 
	for icat=1 NbEtoile
		RAD_TO_RA  ListeAD[icat] alpha$    
		RAD_TO_DEC ListeDEC[icat] delta$  
		DISTSKY ListeAD[icat] AlphaObjet ListeDEC[icat]  DeltaObjet dist
		RAD_TO_DEC dist dist$
		str icat icat$
		Print icat$ "  RA=" alpha$ " DEC=" delta$  " Magnitude=" ListMagn[icat] " distance=" dist$
	next i

return

# 310 "<stdin>" 2

# 1 "./lib/auto_exposure.pgm" 1

Test_calculFlux_spectre:

	print "-------------------------"
	open Img "C:\Users\tlemoult\Dropbox\astro\scriptPrism\spectroAuto\spectroAutoV1.09 BeChelles\test1.fits" 
	GOSUB Calcul_flux_spectre:
	print "-------------------------"
	open Img "C:\Users\tlemoult\Dropbox\astro\scriptPrism\spectroAuto\spectroAutoV1.09 BeChelles\test2.fits" 
	GOSUB Calcul_flux_spectre:
	exit
	
Test_Autoexposure:
	print "test Auto_exposure"
	exposureTimeObjet=300
	CameraSpectre=2
	DefaultTotalExposure=3600
	NbPoseMax=29
	NbPoseMin=3
	maxDyn=25000
	TargetFlux=300000
	
	GOSUB Auto_exposure:
	exit
	
Auto_exposure:
	if (ExposureMode$="define") then 
		print "Temps de pose definis par le fichier cible"
		print "   Pose unitaire= " exposureTimeObjet " secondes"
		print "   Nb Pose      = " nbExposureObjet " secondes"
		return
	else
		DureeMax=DefaultTotalExposure
	endif

	print "determination du temps de pose et nb de pose optimum"
	print "dureMax= " dureeMax

	poseEval=1
	i=0
boucle_eval_exposure_spectre:
	i=i+1
	Print "   pose evaluation spectre dure:"  poseEval " secondes"
	StartExposure_EX CameraSpectre poseEval*1000
	WaitForEndExposure_EX CameraSpectre
	GetLastImageExposure_EX CameraSpectre img
	STR i i$
	SaveFIT img WorkDir$+NomObjet$+"_evalflux_"+i$+"_"
	GOSUB Calcul_flux_spectre:
	
	if flux<(maxDyn/20) then
		if (poseEval>8) then
			goto exit_boucle_eval_exposure:
		endif
		poseEval=poseEval*10
		Goto boucle_eval_exposure_spectre:
	endif

	if flux>maxDyn then
		if (poseEval<0.005) then
			goto exit_boucle_eval_exposure:
		endif
		poseEval=poseEval/10
		Goto boucle_eval_exposure_spectre:
	endif	
	
exit_boucle_eval_exposure:

	
	Expo=poseEval*maxDyn/flux
	int flux flux
	print "   La pose d evaluation de " poseEval " secondes donne un max ADU=" flux

	GOSUB trunc_single_exposure:
	Print "   La pose unitaire choisie est de " expo " secondes"
	
	if (ExposureMode$="totExposure") THEN
		Print "    Temps exposition total fixe TotExposure=" TotExposure " secondes" 
		NbPose=TotExposure/Expo+1
		Int NbPose NbPose

		if NbPose<NbPoseMin THEN
			NbPose=NbPoseMin
		ENDIF
		
		Expo=TotExposure/NbPose
	ELSE
	
		TotalExpNecessaire=poseEval*TargetFlux/flux
		// additionne 1,  pour eviter de raccourcir trop les temps genre 1.6s, lors de la conversion entiere.
		TotalExpNecessaire=TotalExpNecessaire+1
		print "log TotalExpNecessaire=" TotalExpNecessaire
		int TotalExpNecessaire TotalExpNecessaire
		print "   Temps total exposition necessaire " TotalExpNecessaire " secondes, pour obtenir un flux total minimum de " TargetFlux
		If TotalExpNecessaire>DureeMax THEN
			TotalExpNecessaire=DureeMax
		ENDIF
		print "logf TotalExpNecessaire=" TotalExpNecessaire
		
		NbPose=TotalExpNecessaire/Expo
		
		Int NbPose NbPose
		NbPose=NbPose+1
		print "Loga NbPose=" NbPose
		if NbPose<NbPoseMin THEN
			NbPose=NbPoseMin
			expo=TotalExpNecessaire/NbPoseMin
			print "logb expo=" expo
		ENDIF
		
		if (Expo>DureeMax) then
				Expo=DureeMax
		endif
		
		if NbPose>NbPoseMax THEN
			NbPose=NbPoseMax
		ENDIF


	ENDIF

	print "   On choisit de realiser " NbPose " poses unitaires exposees pendant " Expo " secondes"
	print "   Soit un total de " NbPose*Expo " secondes"
	
	// recupere les valeurs pour la suite du programme.
	nbExposureObjet=NbPose
	exposureTimeObjet=Expo
	
return

trunc_single_exposure:
	if Expo>600 THEN
		Expo=600
	ENDIF
return

Calcul_flux_spectre:
	HEIGHT img h 
	Width  img l 
	//GETBACKGROUND  Img  Background  Sigma
	//print "      Background=" Background
	
	DETOURAGEEXT  img  5  5  (l-5)  (h-5)  OffsetValueCameraSpectre
	median img 1 4 
	GETMINMAX  1  l-1  1  h-1  img  Xmin  Ymin  Valmin  Xmax  Ymax  Valmax  
	flux=Valmax-OffsetValueCameraSpectre
	if (flux<1) then
		flux=1
	endif
	print "      Flux= " flux
	CLEARIMGWINDOWS

return
# 311 "<stdin>" 2

# 1 "./lib/affine_position_fente.pgm" 1
// affine la position de la fente d'un LISA ou LHIRES
//  variable modifie:  fentePosX  fentePosY
// 


affine_position_fente:

	exposure_milli_affine_fente=1000*30
	demi_larg_bande=1
	demi_hauteur_bande=10
	
	test=0
	
	IF test=1 then
		OriFenteHorizon=1
		OriFentevertical=2
		OrientationFente=OriFenteHorizon
		fentePosX=704
		fentePosY=529
		OPEN img "H:\work\champ-test2.fits"
	else
		//Print "Allume la lampe Neon"
		//EXECEXTERNAL   pathPythonInterpreter$ PythonScriptNeonLISALHIRESOn$
		StartExposure_EX CameraChamp exposure_milli_affine_fente
		WaitForEndExposure_EX CameraChamp
		GetLastImageExposure_EX CameraChamp img
	endif
	
	print "affine_position_fente:"
	print "   initialement  X=" fentePosX " Y=" fentePosY
//	median img 1 3 
	
	
	if OrientationFente=OriFenteHorizon then
		print "   fente horizontale"
		// fenetre une bande perpendiculaire a la position approximaive de la fente

		X1=fentePosX-demi_larg_bande
		Y1=fentePosY-demi_hauteur_bande
		X2=fentePosX+demi_larg_bande
		Y2=fentePosY+demi_hauteur_bande
		GETMINMAX  X1  X2 Y1 Y2 img  Xmin  Ymin  Valmin  Xmax  Ymax  Valmax  
		GuidePosYBin=Ymin
		WINDOW  Img  X1 Y1 X2 Y2
		autovisu Img
		
	endif

	//EXECEXTERNAL   pathPythonInterpreter$ PythonScriptNeonLISALHIRESOff$
	print "   ajuste  X= " fentePosX "  Y= " fentePosY
	close img
	CLEARIMGWINDOWS
return
# 312 "<stdin>" 2

# 1 "./lib/test_etoile_seule_fenetre.pgm" 1
test_etoile_seule_fenetre:
	// X,Y  centre fenetre
	// w:  demilargeur
	// img:  image

	
//	open img "F:\work\champ4.fits" 
//	X=548-1
//	Y=475-1
//	w=30

	// sortie: dist et etoile seule

	WINDOW  img  X-w  Y-w  X+w  Y+w	
	Resol=3
	GETSTARLIST img Resol NbStars ListX ListY ListFlux
	
	print "   Nbstar=" NbStars
	if Nbstars=0 then
		// c est pas bon pas d etoile du tout..  (trop grosse ?)
		etoile_seule=0
		return
	endif

	print "Bright star of windows center X=" X " Y=" Y "   BrightX=" ListX[0]-w+X " BrightY=" ListY[0]-w+Y

	SQR (w-ListX[0])*(w-ListX[0])+(w-ListY[0])*(w-ListY[0]) dist
	print "dist=" dist
 	if (dist<8) then
		etoile_seule=1
		fluxetoileSeule=ListFlux[0]
	else
		etoile_seule=0
	endif
	
	print "   resultat=" etoile_seule
return
# 313 "<stdin>" 2

# 1 "./lib/test_etoile_seule_fenetre_bright.pgm" 1
test_etoile_seule_fenetre_bright:
	// X,Y  centre fenetre
	// w:  demilargeur
	// img:  image

	
//	open img "F:\work\champ4.fits" 
//	X=548-1
//	Y=475-1
//	w=30

	// sortie: dist et etoile seule
	X1=X-w
	Y1=Y-w
	X2=X+w
	Y2=Y+w
	
	if X1<0 then 
		X1=0
	endif
	if Y1<0 then 
		X1=0
	endif
	if X2<0 then 
		X1=0
	endif
	if Y2<0 then 
		X1=0
	endif
	HEIGHT img h 
	Width  img l
	if X1>l-1 then
		X1=l-1
	endif
	if X2>l-1 then
		X2=l-1
	endif
	if Y1>h-1 then
		Y1=h-1
	endif
	if Y2>h-1 then
		Y2=h-1
	endif

	GETMINMAX  X1  X2  Y1  Y2  img  Xmin  Ymin  Valmin  Xmax  Ymax  Valmax  
	
	print "Bright star of windows center X=" X " Y=" Y "   BrightX=" Xmax " BrightY=" Ymax
	Xbright=Xmax
	Ybright=Ymax
	SQR (X-Xmax)*(X-Xmax)+(Y-Ymax)*(Y-Ymax) dist
	print "dist=" dist
 	if (dist<8) then
		etoile_seule=1
		fluxetoileSeule=Valmax
	else
		etoile_seule=0
	endif
	
	print "   resultat=" etoile_seule
return
# 314 "<stdin>" 2

# 1 "./lib/dialog_param_charge_LST_et_defini_cible.pgm" 1
Dialog_param_et_Charge_LST_et_defini_cible:

	resetdlgbox

	adddlgbox 1 30000 1 "Temps d exposition maximum par cible" DefaultTotalExposure
	adddlgbox 2 200 1 "Nombre de pose maximum par cible"  NbPoseMax
	adddlgbox 2 200 1 "Nombre de pose minimum par cible" NbPoseMin
	adddlgbox 2 10000000 1 "FLUX a cummuler par cible" TargetFlux
	adddlgbox 2 125000 1 "FLUX max par pose unitaire" maxDyn
	adddlgbox 6 "repertoire du fichier . LST des cibles" DirCible$
	adddlgbox 5 "Lancement immediat des observations, sans condition meteo"  ActiveLancementImmediat
	adddlgbox 5 "Parking telescope en fin de session" ActiveParkingTelescope
	adddlgbox 5 "Coupure alimentation des cameras en fin de session" ActiveCoupureCameraFinSession
	adddlgbox 5 "acquisition de Flat LISALHIRES en Fin de session" ActiveFlatLISALHIRESFinSession
	adddlgbox 2 200 1 "Nombre de pose FLAT LISA LHIRES" NbFlatLISALHIRES
	adddlgbox 2 200 1 "Temps de pose en secondes des FLAT LISA LHIRES" exposureTimeFLATLISA
	adddlgbox 1 25 0 "Ciel: Mag limite pour observer" LimitMagnitudeCiel
	
	dispdlgbox result
	if (result=1)
		getdlgbox DefaultTotalExposure
		getdlgbox NbPoseMax
		getdlgbox NbPoseMin
		getdlgbox TargetFlux
		getdlgbox maxDyn
		getdlgbox DirCible$
		getdlgbox ActiveLancementImmediat
		getdlgbox ActiveParkingTelescope
		getdlgbox ActiveCoupureCameraFinSession
		getdlgbox ActiveFlatLISALHIRESFinSession
		getdlgbox NbFlatLISALHIRES
		getdlgbox exposureTimeFLATLISA
		getdlgbox LimitMagnitudeCiel
	endif
	
	GETLISTFILENAMEEX  "selection des cibles"  "*.lst" DirCible$  FilesList$  NbFichier

	if NBFichier=0 then
		print "aucun fichier cible selectionne"
		nBCibles=0
		return
	endif
	
REM	NomFichier$="C:\Users\tlemoult\Dropbox\astro\scriptPrism\spectroAuto\spectroAutoV1.10 BeChelles\cibles\B-mag6-11-ra1-2.lst"
	NomFichier$=FilesList[1]$
	print "Chargement du fichier de cible et verification syntaxe"
	print "Fichier de cible=" NomFichier$
	FileExists NomFichier$ ResultatTest
	
	if ResultatTest=0 then
		Print "Le fichier " NomFichier$ "n existe pas"
		Print "Aucune cible chargee"
		nBCibles=0
		return
	endif

	Niveau1LST$=""""
	NIveau2LST$=" "
	
	OPEN_FILETXT_FOR_READ f1 NomFichier$

	i=1
boucle_read_cible:
	READFILETXT f1 ligne$
	if ligne$="" then
		print "ligne vide, on est a la fin du fichier"
		goto exit_boucle_read_cible:
	else
		rem print "Ligne=" ligne$
	endif
	
	CUTSTR ligne$ Niveau1LST$ 1 Nom$
	CUTSTR ligne$ Niveau1LST$ 3 Comment$
	CUTSTR ligne$ Niveau1LST$ 2 ligne1$
	CUTSTR ligne1$ Niveau2LST$ 1 RA$
	CUTSTR ligne1$ Niveau2LST$ 2 DEC$
	CUTSTR ligne1$ Niveau2LST$ 3 MAG$
	CUTSTR ligne1$ Niveau2LST$ 4 Observe$

//	print "-----------------------"
	print "cible no " i
	print "nom= " Nom$
//	print "Comment= " Comment$
//	print "RA= " RA$
//	print "DEC= " DEC$
//	print "Mag= " MAG$
//	print "Observe= " Observe$
	
	if Observe$="TRUE" then
		print "deja observe, on le saute"
		goto boucle_read_cible:
	endif

	// pour verifier le format RA et DEC
	RA_TO_RAD RA$ alphaObjet
	DEC_TO_RAD DEC$ deltaObjet
	val MAG$ mag

	NomObjet[i]$=Nom$
	AltName[i]$=""
	Comment[i]$=Comment$
	Magnitude[i]=mag
	Alpha[i]$=RA$
	Delta[i]$=DEC$
	nbExposureObjet[i]=0
	exposureTimeObjet[i]=DefaultTotalExposure
	CalibrationAsk[i]=1
	Observe[i]$="FALSE"
	LigneLST[i]$=ligne$
	
	GOSUB read_key_word_in_comment:

	// stocke les resultats definis par les mots clef.
	ProjectObject[i]$=ProjectObject$
	IsRef[i]$=IsRef$
	GuideMode[i]$=GuideMode$
	GuideRA[i]$=RAGuide$
	GuideDEC[i]$=DECGuide$
	ExposureMode[i]$=ExposureMode$
	ExposureUnit[i]=ExposureUnit
    Nbexposure[i]=Nbexposure
    TotExposure[i]=TotExposure
	
	i=i+1
	
	goto boucle_read_cible:
exit_boucle_read_cible:

	nBCibles=i-1
	Print "Chargement d un total de " nBCibles " cibles"
	
	return
	
/////////////////////
//  lit les mots clef dans la variable  comment$
////////////////////
read_key_word_in_comment:

// compte le nombre de champ separee par & 
   id=1
loop_terme:
   cutstr Comment$ "&" id terme$
   if  terme$="" then
		nbTerme=id-1
		goto exit_terme:
	endif
   Tabterme[id]$=terme$
   id=id+1
   goto loop_terme:
exit_terme:

// lit    key=value
// on definit les valeur par default.
   GuideMode$="default"
   RAGuide$=""
   DECGuide$=""
   ProjectObject$="none"
   IsRef$="false"

   ExposureMode$="default"
   ExposureUnit=1
   Nbexposure=1
   TotExposure=1

// ici on scrute	
   for j=1 nbTerme
		posStr Tabterme[j]$ "=" pos
		if pos<>0 then
			cutstr Tabterme[j]$ "=" 1 key$
			cutstr Tabterme[j]$ "=" 2 value$
			//print "key:" key$ "  value:" value$
			
			if key$="GuideRA" then
				RAGuide$=value$
				RA_TO_RAD RAGuide$ RAGuide
			endif
			
			if key$="GuideDEC" then
				DECGuide$=value$
				DEC_TO_RAD DECGuide$ DECGuide
				GuideMode$="Coord"
			endif

			if key$="ExposureTime" then
				val value$ value
				ExposureUnit=value
			endif

			if key$="NbExposure" then
				val value$ value
				Nbexposure=value
			    ExposureMode$="define"
			endif
			
			if key$="TotExposure" then
				val value$ value
				TotExposure=value
				ExposureMode$="totExposure"
			endif
			
			if key$="Project" then
				ProjectObject$=value$
				print "Project=" value$
			endif
			
			if key$="IsRef" then
				IsRef$=value$
			endif
			
	   endif		
   next j
   return
# 315 "<stdin>" 2

# 1 "./lib/photometrieChercheur.pgm" 1


PosePhotometrieChercheur:
	if CameraChercheurPresente=1 then
		Print "Pose Photometrie au Chercheur"
		StartExposure_EX CameraChercheur (exposurePhotometrieChercheur*1000)
		WaitForEndExposure_EX CameraChercheur
		GetLastImageExposure_EX CameraChercheur ImgPhotometrie
		SaveFIT ImgPhotometrie WorkDir$+NomObjet$+"_PhotoChercheur"
		close ImgPhotometrie
		CLEARIMGWINDOWS
	endif

return



# 316 "<stdin>" 2

# 1 "./lib/JSON_obs.pgm" 1


test_write_JSON_Observation:

WorkDir$="c:\ccd\"
NomObjet$="P cyg"
AlphaObjet$="12h45d89s"
DeltaObjet$="+38d23m65s"
ProjectObject$="Bess"
TempCameraSpectre=5
binCameraSpectre=2
SPECTROGRAPHE$="ESHEL"
IsRef$="false"
currentStatusObs$="started"
gosub write_JSON_Observation:
exit


write_JSON_Observation:

	Open_FileTxt_For_Rewrite fileJSON WorkDir$+"observation.json"
	Print "Ecris le fichier JSON avec les details de l objet: "+NomObjet$

	WriteFileTxt fileJSON "{"
	WriteFileTxt fileJSON " ""Comment"": ""acquisition JSON file generated by PRISM at end of acquisition"", "
	WriteFileTxt fileJSON " ""jsonType"": ""acquisitionFile"", "
	WriteFileTxt fileJSON " ""formatVersion"": ""0.0.1"",  "
	WriteFileTxt fileJSON ""

	JSONLINE$="  ""statusObs"":"""+currentStatusObs$+""","
	WriteFileTxt fileJSON JSONLINE$
	
	WriteFileTxt fileJSON " ""target"": {"

	JSONLINE$="    ""isRef"":"+IsRef$+","
	WriteFileTxt fileJSON JSONLINE$

	JSONLINE$="     ""objname"": [ """+NomObjet$+"""],"
	WriteFileTxt fileJSON  JSONLINE$

	WriteFileTxt fileJSON "     ""coord"": {  "
	JSONLINE$="       ""ra"" :"""+AlphaObjet$+""","
	WriteFileTxt fileJSON  JSONLINE$
	JSONLINE$="       ""dec"" :"""+DeltaObjet$+""","
	WriteFileTxt fileJSON  JSONLINE$
	WriteFileTxt fileJSON "       ""equinox"": ""J2000"" "	
	WriteFileTxt fileJSON "     }"
	WriteFileTxt fileJSON "  },"
	WriteFileTxt fileJSON ""
	WriteFileTxt fileJSON "  ""project"": """+ProjectObject$+""", "
    WriteFileTxt fileJSON ""
	WriteFileTxt fileJSON "  ""instrument"": {"

	WriteFileTxt fileJSON "     ""telescop"": ""Celestron C14"", "
	WriteFileTxt fileJSON "     ""diameter"": 0.356, "
	WriteFileTxt fileJSON "     ""detname"": ""ATIK460"","
	WriteFileTxt fileJSON "     ""guideDetname"": ""ATIK314"","
	
	if SPECTROGRAPHE$="ESHEL" then
	WriteFileTxt fileJSON "     ""configName"": ""C14 eShel ATIK460"", "
	WriteFileTxt fileJSON "     ""spectro"": ""eShel"", "
	WriteFileTxt fileJSON "     ""resol"": 11000, "
	ENDIF

	if SPECTROGRAPHE$="LISA" then
	WriteFileTxt fileJSON "     ""configname"": ""C14 red063 LISA#127 Slit35 ATIK314L+"", "
	WriteFileTxt fileJSON "     ""spectro"": ""LISA"", "
	WriteFileTxt fileJSON "     ""resol"": 800, "
	ENDIF

	if SPECTROGRAPHE$="ALPY" then
	WriteFileTxt fileJSON "     ""configname"": ""C14 F5 ALPY ATIK314L+"", "
	WriteFileTxt fileJSON "     ""spectro"": ""ALPY"", "
	WriteFileTxt fileJSON "     ""resol"": 600, "
	ENDIF
	
	STR TempCameraSpectre TempCameraSpectre$
	WriteFileTxt fileJSON "     ""TemperatureCCD"":"+TempCameraSpectre$+","
	STR binCameraSpectre binCameraSpectre$
	WriteFileTxt fileJSON "     ""BinCCD"":"+binCameraSpectre$
	WriteFileTxt fileJSON "     },"
	
	WriteFileTxt fileJSON "		""site"": {"
	WriteFileTxt fileJSON "		""name"": ""Chelles"","
	WriteFileTxt fileJSON "		""country"": ""France"","
	WriteFileTxt fileJSON "		""lat"": ""48 52 49"","
	WriteFileTxt fileJSON "		""lon"": ""02 34 55"","
	WriteFileTxt fileJSON "		""alt"": "30","
	WriteFileTxt fileJSON "		""UAIcode"": ""C61"" "
	WriteFileTxt fileJSON "     },"
	
	WriteFileTxt fileJSON "   ""observer"": {"
	WriteFileTxt fileJSON "		""firstName"":""Thierry"","
	WriteFileTxt fileJSON "		""lastName"":""Lemoult"","
	WriteFileTxt fileJSON "		""email"":""thierry.lemoult@gmail.com"","
	WriteFileTxt fileJSON "		""alias"": ""Thierry Lemoult"" "
	WriteFileTxt fileJSON "		}"

	if currentStatusObs$="finished" then
		STR iacqu nbExposure$
		STR exposure exposure$
		TotalExposure=exposure*iacqu
		STR  TotalExposure TotalExposure$
		WriteFileTxt fileJSON ","
		WriteFileTxt fileJSON "  ""obsConfig"": {"
		WriteFileTxt fileJSON "		""NbExposure"":"+nbExposure$+","
		WriteFileTxt fileJSON "		""ExposureTime"":"+exposure$+","
		WriteFileTxt fileJSON "		""TotalExposure"":"+TotalExposure$
		WriteFileTxt fileJSON "		}"
	endif


	WriteFileTxt fileJSON "}"
	CloseFileTxt fileJSON

	
	Open_FileTxt_For_Rewrite fileNewRaw DirectorySignals$+"\newRawData"
	WriteFileTxt fileNewRaw "dummy"
	CloseFileTxt fileNewRaw
		
	
	RETURN

	
# 317 "<stdin>" 2

